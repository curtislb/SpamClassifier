From samba-technical-bounces+ktwarwic=speedy.uwaterloo.ca@lists.samba.org  Wed May  9 07:46:19 2007
Return-Path: <samba-technical-bounces+ktwarwic=speedy.uwaterloo.ca@lists.samba.org>
Received: from lists.samba.org (mail.samba.org [66.70.73.150])
	by flax9.uwaterloo.ca (8.12.8/8.12.5) with ESMTP id l49BkHqD028503
	for <ktwarwic@speedy.uwaterloo.ca>; Wed, 9 May 2007 07:46:18 -0400
Received: from dp.samba.org (localhost [127.0.0.1])
	by lists.samba.org (Postfix) with ESMTP id 6EAC61638BD
	for <ktwarwic@speedy.uwaterloo.ca>; Wed,  9 May 2007 11:46:16 +0000 (GMT)
X-Spam-Checker-Version: SpamAssassin 3.1.7 (2006-10-05) on dp.samba.org
X-Spam-Level: 
X-Spam-Status: No, score=0.3 required=3.8 tests=AWL, BAYES_50, FORGED_RCVD_HELO,
	RCVD_IN_DSBL,UPPERCASE_25_50 autolearn=no version=3.1.7
X-Original-To: samba-technical@lists.samba.org
Delivered-To: samba-technical@lists.samba.org
X-Greylist: delayed 1129 seconds by postgrey-1.24 at dp.samba.org;
	Wed, 09 May 2007 11:45:05 GMT
Received: from pollux.warande.net (pollux.sshunet.nl [145.97.192.42])
	by lists.samba.org (Postfix) with ESMTP id BD870162AD5
	for <samba-technical@lists.samba.org>;
	Wed,  9 May 2007 11:45:05 +0000 (GMT)
Received: from localhost (localhost.localdomain [127.0.0.1])
	by pollux.warande.net (Postfix) with ESMTP id AC2CE58001B;
	Wed,  9 May 2007 13:26:15 +0200 (CEST)
Received: from pollux.warande.net ([127.0.0.1])
	by localhost (pollux [127.0.0.1]) (amavisd-new, port 10024)
	with ESMTP id 12316-10; Wed, 9 May 2007 13:26:15 +0200 (CEST)
Received: from ganieda.vernstok.nl (42pc197.sshunet.nl [145.97.197.42])
	by pollux.warande.net (Postfix) with ESMTP;
	Wed,  9 May 2007 13:26:15 +0200 (CEST)
Received: from [127.0.0.1] (localhost [127.0.0.1])
	by ganieda.vernstok.nl (Postfix) with ESMTP id 4B7DB5C4883;
	Wed,  9 May 2007 13:26:15 +0200 (CEST)
Message-ID: <4641AFD7.7070903@vernstok.nl>
Date: Wed, 09 May 2007 13:26:15 +0200
From: Jelmer Vernooij <jelmer@vernstok.nl>
User-Agent: Thunderbird 1.5.0.10 (X11/20070403)
MIME-Version: 1.0
To: Volker.Lendecke@SerNet.DE
References: <20070509011204.0E02D5C4932@ganieda.vernstok.nl>
	<E1HlgUM-0000tP-CE@intern.SerNet.DE>
In-Reply-To: <E1HlgUM-0000tP-CE@intern.SerNet.DE>
X-Enigmail-Version: 0.94.2.0
Content-Type: multipart/mixed; boundary="------------040101030009020405090304"
X-Virus-Scanned: by amavisd-new-20030616-p10 (Debian) at sshunet.nl
Cc: samba-technical@lists.samba.org
Subject: Re: Rev 12123: Use context for loadparm functions.
	in	file:///home/jelmer/bzr.samba/SAMBA_4_0/
X-BeenThere: samba-technical@lists.samba.org
X-Mailman-Version: 2.1.5
Precedence: list
List-Id: "Discussions on Samba internals. For general questions please
	subscribe to the list samba@samba.org"
	<samba-technical.lists.samba.org>
List-Unsubscribe: <https://lists.samba.org/mailman/listinfo/samba-technical>, 
	<mailto:samba-technical-request@lists.samba.org?subject=unsubscribe>
List-Archive: <http://lists.samba.org/archive/samba-technical>
List-Post: <mailto:samba-technical@lists.samba.org>
List-Help: <mailto:samba-technical-request@lists.samba.org?subject=help>
List-Subscribe: <https://lists.samba.org/mailman/listinfo/samba-technical>,
	<mailto:samba-technical-request@lists.samba.org?subject=subscribe>
Sender: samba-technical-bounces+ktwarwic=speedy.uwaterloo.ca@lists.samba.org
Errors-To: samba-technical-bounces+ktwarwic=speedy.uwaterloo.ca@lists.samba.org

This is a multi-part message in MIME format.
--------------040101030009020405090304
Content-Type: text/plain; charset=ISO-8859-1
Content-Transfer-Encoding: 7bit

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1

Volker Lendecke wrote:
> On Wed, May 09, 2007 at 03:12:03AM +0200, Jelmer Vernooij wrote:
>> At file:///home/jelmer/bzr.samba/SAMBA_4_0/
>>
>> ------------------------------------------------------------
>> revno: 12123
>> revision-id: jelmer@samba.org-20070509011150-9opq848pjvql0065
>> parent: svn-v2:22758@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0
>> committer: Jelmer Vernooij <jelmer@samba.org>
>> branch nick: SAMBA_4_0
>> timestamp: Wed 2007-05-09 03:11:50 +0200
>> message:
>>   Use context for loadparm functions.
> Can I see the patch? This sounds interesting for s3 as well :-)
I've attached the patch for this revision. I'll send out a full patch
once I'm done with loadparm; I'm also working on making it use talloc
inside.

Cheers,

Jelmer
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.6 (GNU/Linux)
Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org

iQCVAwUBRkGvygy0JeEGD2blAQIRFAP/U/QoYu0b2gPPURc890JcBbn7pWl0VAkg
/oY3dWK65LYqxdi7YNVWvLbTMe49rlp0mgQsulVeu4FMq35QuwY3ToVSPrzzD4tK
PArxP774yMI9q1aRoZYIEY4PKqxV4nVW72g8Uiim2jQWRjR05S2Sq8bf6aHZX9tS
spVzhqeQPvw=
=dtaZ
-----END PGP SIGNATURE-----

--------------040101030009020405090304
Content-Type: text/x-patch;
 name="loadparm-ctx.bundle.diff"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="loadparm-ctx.bundle.diff"

# Bazaar revision bundle v0.9
#
# message:
#   Use context for loadparm functions.
# committer: Jelmer Vernooij <jelmer@samba.org>
# date: Wed 2007-05-09 03:11:50.144000053 +0200

=== modified file source/client/cifsdd.c
--- source/client/cifsdd.c
+++ source/client/cifsdd.c
@@ -395,7 +395,7 @@
 	char buf[64];
 
 	snprintf(buf, sizeof(buf), "%llu", (unsigned long long)iomax);
-	lp_set_cmdline("max xmit", buf);
+	lp_set_cmdline(&global_params, "max xmit", buf);
 }
 
 static int copy_files(void)

=== modified file source/lib/charset/charcnv.c
--- source/lib/charset/charcnv.c
+++ source/lib/charset/charcnv.c
@@ -115,7 +115,7 @@
 		    strcasecmp(charset_name(CH_DOS), "ASCII") != 0) {
 			DEBUG(0,("dos charset '%s' unavailable - using ASCII\n",
 				 charset_name(CH_DOS)));
-			lp_set_cmdline("dos charset", "ASCII");
+			lp_set_cmdline(&global_params, "dos charset", "ASCII");
 
 			n1 = charset_name(from);
 			n2 = charset_name(to);

=== modified file source/lib/cmdline/popt_common.c
--- source/lib/cmdline/popt_common.c
+++ source/lib/cmdline/popt_common.c
@@ -71,14 +71,15 @@
 		setup_logging(pname, DEBUG_STDOUT);
 
 		if (getenv("SMB_CONF_PATH")) {
-			lp_set_cmdline("config file", getenv("SMB_CONF_PATH"));
+			lp_set_cmdline(&global_params, "config file", 
+						   getenv("SMB_CONF_PATH"));
 		}
 		return;
 	}
 
 	switch(opt->val) {
 	case 'd':
-		lp_set_cmdline("log level", arg);
+		lp_set_cmdline(&global_params, "log level", arg);
 		break;
 
 	case OPT_DEBUG_STDERR:
@@ -92,50 +93,50 @@
 
 	case 'O':
 		if (arg) {
-			lp_set_cmdline("socket options", arg);
+			lp_set_cmdline(&global_params, "socket options", arg);
 		}
 		break;
 
 	case 's':
 		if (arg) {
-			lp_set_cmdline("config file", arg);
+			lp_set_cmdline(&global_params, "config file", arg);
 		}
 		break;
 
 	case 'l':
 		if (arg) {
 			char *new_logfile = talloc_asprintf(NULL, "%s/log.%s", arg, pname);
-			lp_set_cmdline("log file", new_logfile);
+			lp_set_cmdline(&global_params, "log file", new_logfile);
 			talloc_free(new_logfile);
 		}
 		break;
 		
 	case 'W':
-		lp_set_cmdline("workgroup", arg);
+		lp_set_cmdline(&global_params, "workgroup", arg);
 		break;
 
 	case 'r':
-		lp_set_cmdline("realm", arg);
+		lp_set_cmdline(&global_params, "realm", arg);
 		break;
 		
 	case 'n':
-		lp_set_cmdline("netbios name", arg);
+		lp_set_cmdline(&global_params, "netbios name", arg);
 		break;
 		
 	case 'i':
-		lp_set_cmdline("netbios scope", arg);
+		lp_set_cmdline(&global_params, "netbios scope", arg);
 		break;
 
 	case 'm':
-		lp_set_cmdline("client max protocol", arg);
+		lp_set_cmdline(&global_params, "client max protocol", arg);
 		break;
 
 	case 'R':
-		lp_set_cmdline("name resolve order", arg);
+		lp_set_cmdline(&global_params, "name resolve order", arg);
 		break;
 
 	case OPT_OPTION:
-		if (!lp_set_option(arg)) {
+		if (!lp_set_option(&global_params, arg)) {
 			fprintf(stderr, "Error setting option '%s'\n", arg);
 			exit(1);
 		}

=== modified file source/lib/cmdline/popt_credentials.c
--- source/lib/cmdline/popt_credentials.c
+++ source/lib/cmdline/popt_credentials.c
@@ -96,7 +96,7 @@
 		break;
 
 	case 'S':
-		lp_set_cmdline("client signing", arg);
+		lp_set_cmdline(&global_params, "client signing", arg);
 		break;
 
 	case 'P':

=== modified file source/param/loadparm.c
--- source/param/loadparm.c
+++ source/param/loadparm.c
@@ -64,18 +64,19 @@
 #include "lib/util/dlinklist.h"
 #include "param/loadparm.h"
 
-static BOOL bLoaded = False;
+static BOOL bLoaded = false;
 
 #define standard_sub_basic(str,len)
 
 /* some helpful bits */
-#define LP_SNUM_OK(i) (((i) >= 0) && ((i) < iNumServices) && ServicePtrs[(i)]->valid)
-#define VALID(i) ServicePtrs[i]->valid
-
-static BOOL do_parameter(const char *, const char *, void *);
-static BOOL do_parameter_var(const char *pszParmName, const char *fmt, ...);
-
-static BOOL defaults_saved = False;
+#define LP_SNUM_OK(i) (((i) >= 0) && ((i) < global_params.iNumServices) && global_params.ServicePtrs[(i)]->valid)
+#define VALID(i) global_params.ServicePtrs[i]->valid
+
+static BOOL do_parameter_var(struct loadparm_context *, 
+							 const char *pszParmName, const char *fmt, ...);
+static BOOL do_parameter(struct loadparm_context *, const char *, const char *);
+
+static BOOL defaults_saved = false;
 
 
 struct param_opt {
@@ -269,16 +270,26 @@
 };
 
 /* local variables */
-static service **ServicePtrs = NULL;
-static int iNumServices = 0;
 static int iServiceIndex = 0;
-static BOOL bInGlobalSection = True;
+static BOOL bInGlobalSection = true;
+
+struct loadparm_context {
+	int iNumServices;
+	service **ServicePtrs;
+};
+
+struct loadparm_context global_params = {
+	.iNumServices = 0,
+	.ServicePtrs = NULL,
+};
 
 #define NUMPARAMETERS (sizeof(parm_table) / sizeof(struct parm_struct))
 
 /* prototypes for the special type handlers */
-static BOOL handle_include(const char *pszParmValue, char **ptr);
-static BOOL handle_copy(const char *pszParmValue, char **ptr);
+static BOOL handle_include(struct loadparm_context *ctx, 
+						   const char *pszParmValue, char **ptr);
+static BOOL handle_copy(struct loadparm_context *ctx, 
+						const char *pszParmValue, char **ptr);
 
 static const struct enum_list enum_protocol[] = {
 	{PROTOCOL_SMB2, "SMB2"},
@@ -359,6 +370,8 @@
 	{-1, NULL}
 };
 
+#define GLOBALS_OFFSET(name) &Globals.name
+#define DEFAULT_OFFSET(name) &sDefault.name
 
 /* Note: We do not initialise the defaults union - it is not allowed in ANSI C
  *
@@ -373,55 +386,55 @@
 static struct parm_struct parm_table[] = {
 	{"Base Options", P_SEP, P_SEPARATOR},
 
-	{"server role", P_ENUM, P_GLOBAL, &Globals.server_role, NULL, enum_server_role, FLAG_BASIC},
+	{"server role", P_ENUM, P_GLOBAL, GLOBALS_OFFSET(server_role), NULL, enum_server_role, FLAG_BASIC},
 
-	{"dos charset", P_STRING, P_GLOBAL, &Globals.dos_charset, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"unix charset", P_STRING, P_GLOBAL, &Globals.unix_charset, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"ncalrpc dir", P_STRING, P_GLOBAL, &Globals.ncalrpc_dir, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"display charset", P_STRING, P_GLOBAL, &Globals.display_charset, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"comment", P_STRING, P_LOCAL, &sDefault.comment, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE | FLAG_PRINT | FLAG_DEVELOPER},
-	{"path", P_STRING, P_LOCAL, &sDefault.szPath, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE | FLAG_PRINT | FLAG_DEVELOPER},
-	{"directory", P_STRING, P_LOCAL, &sDefault.szPath, NULL, NULL, FLAG_HIDE},
-	{"workgroup", P_USTRING, P_GLOBAL, &Globals.szWorkgroup, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"realm", P_STRING, P_GLOBAL, &Globals.szRealm, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"netbios name", P_USTRING, P_GLOBAL, &Globals.szNetbiosName, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"netbios aliases", P_LIST, P_GLOBAL, &Globals.szNetbiosAliases, NULL, NULL, FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"netbios scope", P_USTRING, P_GLOBAL, &Globals.szNetbiosScope, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"server string", P_STRING, P_GLOBAL, &Globals.szServerString, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED  | FLAG_DEVELOPER},
-	{"interfaces", P_LIST, P_GLOBAL, &Globals.szInterfaces, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"bind interfaces only", P_BOOL, P_GLOBAL, &Globals.bBindInterfacesOnly, NULL, NULL, FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"ntvfs handler", P_LIST, P_LOCAL, &sDefault.ntvfs_handler, NULL, NULL, FLAG_ADVANCED},
-	{"ntptr providor", P_STRING, P_GLOBAL, &Globals.ntptr_providor, NULL, NULL, FLAG_ADVANCED},
-	{"dcerpc endpoint servers", P_LIST, P_GLOBAL, &Globals.dcerpc_ep_servers, NULL, NULL, FLAG_ADVANCED},
-	{"server services", P_LIST, P_GLOBAL, &Globals.server_services, NULL, NULL, FLAG_ADVANCED},
+	{"dos charset", P_STRING, P_GLOBAL, GLOBALS_OFFSET(dos_charset), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"unix charset", P_STRING, P_GLOBAL, GLOBALS_OFFSET(unix_charset), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"ncalrpc dir", P_STRING, P_GLOBAL, GLOBALS_OFFSET(ncalrpc_dir), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"display charset", P_STRING, P_GLOBAL, GLOBALS_OFFSET(display_charset), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"comment", P_STRING, P_LOCAL, DEFAULT_OFFSET(comment), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE | FLAG_PRINT | FLAG_DEVELOPER},
+	{"path", P_STRING, P_LOCAL, DEFAULT_OFFSET(szPath), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE | FLAG_PRINT | FLAG_DEVELOPER},
+	{"directory", P_STRING, P_LOCAL, DEFAULT_OFFSET(szPath), NULL, NULL, FLAG_HIDE},
+	{"workgroup", P_USTRING, P_GLOBAL, GLOBALS_OFFSET(szWorkgroup), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"realm", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szRealm), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"netbios name", P_USTRING, P_GLOBAL, GLOBALS_OFFSET(szNetbiosName), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"netbios aliases", P_LIST, P_GLOBAL, GLOBALS_OFFSET(szNetbiosAliases), NULL, NULL, FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"netbios scope", P_USTRING, P_GLOBAL, GLOBALS_OFFSET(szNetbiosScope), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"server string", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szServerString), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED  | FLAG_DEVELOPER},
+	{"interfaces", P_LIST, P_GLOBAL, GLOBALS_OFFSET(szInterfaces), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"bind interfaces only", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bBindInterfacesOnly), NULL, NULL, FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"ntvfs handler", P_LIST, P_LOCAL, DEFAULT_OFFSET(ntvfs_handler), NULL, NULL, FLAG_ADVANCED},
+	{"ntptr providor", P_STRING, P_GLOBAL, GLOBALS_OFFSET(ntptr_providor), NULL, NULL, FLAG_ADVANCED},
+	{"dcerpc endpoint servers", P_LIST, P_GLOBAL, GLOBALS_OFFSET(dcerpc_ep_servers), NULL, NULL, FLAG_ADVANCED},
+	{"server services", P_LIST, P_GLOBAL, GLOBALS_OFFSET(server_services), NULL, NULL, FLAG_ADVANCED},
 
 	{"Security Options", P_SEP, P_SEPARATOR},
 	
-	{"security", P_ENUM, P_GLOBAL, &Globals.security, NULL, enum_security, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"auth methods", P_LIST, P_GLOBAL, &Globals.AuthMethods, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"encrypt passwords", P_BOOL, P_GLOBAL, &Globals.bEncryptPasswords, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"null passwords", P_BOOL, P_GLOBAL, &Globals.bNullPasswords, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"obey pam restrictions", P_BOOL, P_GLOBAL, &Globals.bObeyPamRestrictions, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"password server", P_LIST, P_GLOBAL, &Globals.szPasswordServers, NULL, NULL, FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"sam database", P_STRING, P_GLOBAL, &Globals.szSAM_URL, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"secrets database", P_STRING, P_GLOBAL, &Globals.szSECRETS_URL, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"spoolss database", P_STRING, P_GLOBAL, &Globals.szSPOOLSS_URL, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"wins config database", P_STRING, P_GLOBAL, &Globals.szWINS_CONFIG_URL, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"wins database", P_STRING, P_GLOBAL, &Globals.szWINS_URL, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"private dir", P_STRING, P_GLOBAL, &Globals.szPrivateDir, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"passwd chat", P_STRING, P_GLOBAL, &Globals.szPasswdChat, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"password level", P_INTEGER, P_GLOBAL, &Globals.pwordlevel, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"lanman auth", P_BOOL, P_GLOBAL, &Globals.bLanmanAuth, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"ntlm auth", P_BOOL, P_GLOBAL, &Globals.bNTLMAuth, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"client NTLMv2 auth", P_BOOL, P_GLOBAL, &Globals.bClientNTLMv2Auth, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"client lanman auth", P_BOOL, P_GLOBAL, &Globals.bClientLanManAuth, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"client plaintext auth", P_BOOL, P_GLOBAL, &Globals.bClientPlaintextAuth, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"client use spnego principal", P_BOOL, P_GLOBAL, &Globals.client_use_spnego_principal, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"security", P_ENUM, P_GLOBAL, GLOBALS_OFFSET(security), NULL, enum_security, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"auth methods", P_LIST, P_GLOBAL, GLOBALS_OFFSET(AuthMethods), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"encrypt passwords", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bEncryptPasswords), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"null passwords", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bNullPasswords), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"obey pam restrictions", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bObeyPamRestrictions), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"password server", P_LIST, P_GLOBAL, GLOBALS_OFFSET(szPasswordServers), NULL, NULL, FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"sam database", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szSAM_URL), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"secrets database", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szSECRETS_URL), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"spoolss database", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szSPOOLSS_URL), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"wins config database", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szWINS_CONFIG_URL), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"wins database", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szWINS_URL), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"private dir", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szPrivateDir), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"passwd chat", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szPasswdChat), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"password level", P_INTEGER, P_GLOBAL, GLOBALS_OFFSET(pwordlevel), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"lanman auth", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bLanmanAuth), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"ntlm auth", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bNTLMAuth), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"client NTLMv2 auth", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bClientNTLMv2Auth), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"client lanman auth", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bClientLanManAuth), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"client plaintext auth", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bClientPlaintextAuth), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"client use spnego principal", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(client_use_spnego_principal), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
 	
-	{"read only", P_BOOL, P_LOCAL, &sDefault.bRead_only, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE},
+	{"read only", P_BOOL, P_LOCAL, DEFAULT_OFFSET(bRead_only), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE},
 
-	{"hosts allow", P_LIST, P_LOCAL, &sDefault.szHostsallow, NULL, NULL, FLAG_GLOBAL | FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE | FLAG_PRINT | FLAG_DEVELOPER},
-	{"hosts deny", P_LIST, P_LOCAL, &sDefault.szHostsdeny, NULL, NULL, FLAG_GLOBAL | FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE | FLAG_PRINT | FLAG_DEVELOPER},
+	{"hosts allow", P_LIST, P_LOCAL, DEFAULT_OFFSET(szHostsallow), NULL, NULL, FLAG_GLOBAL | FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE | FLAG_PRINT | FLAG_DEVELOPER},
+	{"hosts deny", P_LIST, P_LOCAL, DEFAULT_OFFSET(szHostsdeny), NULL, NULL, FLAG_GLOBAL | FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE | FLAG_PRINT | FLAG_DEVELOPER},
 
 	{"Logging Options", P_SEP, P_SEPARATOR},
 
@@ -431,70 +444,70 @@
 	
 	{"Protocol Options", P_SEP, P_SEPARATOR},
 	
-	{"smb ports", P_LIST, P_GLOBAL, &Globals.smb_ports, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"nbt port", P_INTEGER, P_GLOBAL, &Globals.nbt_port, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"dgram port", P_INTEGER, P_GLOBAL, &Globals.dgram_port, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"cldap port", P_INTEGER, P_GLOBAL, &Globals.cldap_port, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"krb5 port", P_INTEGER, P_GLOBAL, &Globals.krb5_port, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"kpasswd port", P_INTEGER, P_GLOBAL, &Globals.kpasswd_port, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"web port", P_INTEGER, P_GLOBAL, &Globals.web_port, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"tls enabled", P_BOOL, P_GLOBAL, &Globals.tls_enabled, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"tls keyfile", P_STRING, P_GLOBAL, &Globals.tls_keyfile, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"tls certfile", P_STRING, P_GLOBAL, &Globals.tls_certfile, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"tls cafile", P_STRING, P_GLOBAL, &Globals.tls_cafile, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"tls crlfile", P_STRING, P_GLOBAL, &Globals.tls_crlfile, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"tls dh params file", P_STRING, P_GLOBAL, &Globals.tls_dhpfile, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"web application directory", P_STRING, P_GLOBAL, &Globals.webapps_directory, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"large readwrite", P_BOOL, P_GLOBAL, &Globals.bLargeReadwrite, NULL, NULL, FLAG_DEVELOPER},
-	{"server max protocol", P_ENUM, P_GLOBAL, &Globals.srv_maxprotocol, NULL, enum_protocol, FLAG_DEVELOPER},
-	{"server min protocol", P_ENUM, P_GLOBAL, &Globals.srv_minprotocol, NULL, enum_protocol, FLAG_DEVELOPER},
-	{"client max protocol", P_ENUM, P_GLOBAL, &Globals.cli_maxprotocol, NULL, enum_protocol, FLAG_DEVELOPER},
-	{"client min protocol", P_ENUM, P_GLOBAL, &Globals.cli_minprotocol, NULL, enum_protocol, FLAG_DEVELOPER},
-	{"unicode", P_BOOL, P_GLOBAL, &Globals.bUnicode, NULL, NULL, FLAG_DEVELOPER},
-	{"read raw", P_BOOL, P_GLOBAL, &Globals.bReadRaw, NULL, NULL, FLAG_DEVELOPER},
-	{"write raw", P_BOOL, P_GLOBAL, &Globals.bWriteRaw, NULL, NULL, FLAG_DEVELOPER},
-	{"disable netbios", P_BOOL, P_GLOBAL, &Globals.bDisableNetbios, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"smb ports", P_LIST, P_GLOBAL, GLOBALS_OFFSET(smb_ports), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"nbt port", P_INTEGER, P_GLOBAL, GLOBALS_OFFSET(nbt_port), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"dgram port", P_INTEGER, P_GLOBAL, GLOBALS_OFFSET(dgram_port), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"cldap port", P_INTEGER, P_GLOBAL, GLOBALS_OFFSET(cldap_port), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"krb5 port", P_INTEGER, P_GLOBAL, GLOBALS_OFFSET(krb5_port), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"kpasswd port", P_INTEGER, P_GLOBAL, GLOBALS_OFFSET(kpasswd_port), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"web port", P_INTEGER, P_GLOBAL, GLOBALS_OFFSET(web_port), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"tls enabled", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(tls_enabled), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"tls keyfile", P_STRING, P_GLOBAL, GLOBALS_OFFSET(tls_keyfile), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"tls certfile", P_STRING, P_GLOBAL, GLOBALS_OFFSET(tls_certfile), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"tls cafile", P_STRING, P_GLOBAL, GLOBALS_OFFSET(tls_cafile), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"tls crlfile", P_STRING, P_GLOBAL, GLOBALS_OFFSET(tls_crlfile), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"tls dh params file", P_STRING, P_GLOBAL, GLOBALS_OFFSET(tls_dhpfile), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"web application directory", P_STRING, P_GLOBAL, GLOBALS_OFFSET(webapps_directory), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"large readwrite", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bLargeReadwrite), NULL, NULL, FLAG_DEVELOPER},
+	{"server max protocol", P_ENUM, P_GLOBAL, GLOBALS_OFFSET(srv_maxprotocol), NULL, enum_protocol, FLAG_DEVELOPER},
+	{"server min protocol", P_ENUM, P_GLOBAL, GLOBALS_OFFSET(srv_minprotocol), NULL, enum_protocol, FLAG_DEVELOPER},
+	{"client max protocol", P_ENUM, P_GLOBAL, GLOBALS_OFFSET(cli_maxprotocol), NULL, enum_protocol, FLAG_DEVELOPER},
+	{"client min protocol", P_ENUM, P_GLOBAL, GLOBALS_OFFSET(cli_minprotocol), NULL, enum_protocol, FLAG_DEVELOPER},
+	{"unicode", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bUnicode), NULL, NULL, FLAG_DEVELOPER},
+	{"read raw", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bReadRaw), NULL, NULL, FLAG_DEVELOPER},
+	{"write raw", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bWriteRaw), NULL, NULL, FLAG_DEVELOPER},
+	{"disable netbios", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bDisableNetbios), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
 	
-	{"nt status support", P_BOOL, P_GLOBAL, &Globals.bNTStatusSupport, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-
-	{"announce version", P_STRING, P_GLOBAL, &Globals.szAnnounceVersion, NULL, NULL, FLAG_DEVELOPER},
-	{"announce as", P_ENUM, P_GLOBAL, &Globals.announce_as, NULL, enum_announce_as, FLAG_DEVELOPER},
-	{"max mux", P_INTEGER, P_GLOBAL, &Globals.max_mux, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"max xmit", P_BYTES, P_GLOBAL, &Globals.max_xmit, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-
-	{"name resolve order", P_LIST, P_GLOBAL, &Globals.szNameResolveOrder, NULL, NULL, FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"max wins ttl", P_INTEGER, P_GLOBAL, &Globals.max_wins_ttl, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"min wins ttl", P_INTEGER, P_GLOBAL, &Globals.min_wins_ttl, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"time server", P_BOOL, P_GLOBAL, &Globals.bTimeServer, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"unix extensions", P_BOOL, P_GLOBAL, &Globals.bUnixExtensions, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"use spnego", P_BOOL, P_GLOBAL, &Globals.bUseSpnego, NULL, NULL, FLAG_DEVELOPER},
-	{"server signing", P_ENUM, P_GLOBAL, &Globals.server_signing, NULL, enum_smb_signing_vals, FLAG_ADVANCED}, 
-	{"client signing", P_ENUM, P_GLOBAL, &Globals.client_signing, NULL, enum_smb_signing_vals, FLAG_ADVANCED}, 
-	{"rpc big endian", P_BOOL, P_GLOBAL, &Globals.bRpcBigEndian, NULL, NULL, FLAG_DEVELOPER},
+	{"nt status support", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bNTStatusSupport), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+
+	{"announce version", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szAnnounceVersion), NULL, NULL, FLAG_DEVELOPER},
+	{"announce as", P_ENUM, P_GLOBAL, GLOBALS_OFFSET(announce_as), NULL, enum_announce_as, FLAG_DEVELOPER},
+	{"max mux", P_INTEGER, P_GLOBAL, GLOBALS_OFFSET(max_mux), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"max xmit", P_BYTES, P_GLOBAL, GLOBALS_OFFSET(max_xmit), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+
+	{"name resolve order", P_LIST, P_GLOBAL, GLOBALS_OFFSET(szNameResolveOrder), NULL, NULL, FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"max wins ttl", P_INTEGER, P_GLOBAL, GLOBALS_OFFSET(max_wins_ttl), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"min wins ttl", P_INTEGER, P_GLOBAL, GLOBALS_OFFSET(min_wins_ttl), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"time server", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bTimeServer), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"unix extensions", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bUnixExtensions), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"use spnego", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bUseSpnego), NULL, NULL, FLAG_DEVELOPER},
+	{"server signing", P_ENUM, P_GLOBAL, GLOBALS_OFFSET(server_signing), NULL, enum_smb_signing_vals, FLAG_ADVANCED}, 
+	{"client signing", P_ENUM, P_GLOBAL, GLOBALS_OFFSET(client_signing), NULL, enum_smb_signing_vals, FLAG_ADVANCED}, 
+	{"rpc big endian", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bRpcBigEndian), NULL, NULL, FLAG_DEVELOPER},
 
 	{"Tuning Options", P_SEP, P_SEPARATOR},
 		
-	{"max connections", P_INTEGER, P_LOCAL, &sDefault.iMaxConnections, NULL, NULL, FLAG_SHARE},
-	{"paranoid server security", P_BOOL, P_GLOBAL, &Globals.paranoid_server_security, NULL, NULL, FLAG_DEVELOPER},
-	{"socket options", P_STRING, P_GLOBAL, &Globals.socket_options, NULL, NULL, FLAG_DEVELOPER},
+	{"max connections", P_INTEGER, P_LOCAL, DEFAULT_OFFSET(iMaxConnections), NULL, NULL, FLAG_SHARE},
+	{"paranoid server security", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(paranoid_server_security), NULL, NULL, FLAG_DEVELOPER},
+	{"socket options", P_STRING, P_GLOBAL, GLOBALS_OFFSET(socket_options), NULL, NULL, FLAG_DEVELOPER},
 
-	{"strict sync", P_BOOL, P_LOCAL, &sDefault.bStrictSync, NULL, NULL, FLAG_ADVANCED | FLAG_SHARE}, 
-	{"case insensitive filesystem", P_BOOL, P_LOCAL, &sDefault.bCIFileSystem, NULL, NULL, FLAG_ADVANCED | FLAG_SHARE}, 
+	{"strict sync", P_BOOL, P_LOCAL, DEFAULT_OFFSET(bStrictSync), NULL, NULL, FLAG_ADVANCED | FLAG_SHARE}, 
+	{"case insensitive filesystem", P_BOOL, P_LOCAL, DEFAULT_OFFSET(bCIFileSystem), NULL, NULL, FLAG_ADVANCED | FLAG_SHARE}, 
 
 	{"Printing Options", P_SEP, P_SEPARATOR},
 	
-	{"max print jobs", P_INTEGER, P_LOCAL, &sDefault.iMaxPrintJobs, NULL, NULL, FLAG_PRINT},
-	{"printable", P_BOOL, P_LOCAL, &sDefault.bPrint_ok, NULL, NULL, FLAG_PRINT},
-	{"print ok", P_BOOL, P_LOCAL, &sDefault.bPrint_ok, NULL, NULL, FLAG_HIDE},
+	{"max print jobs", P_INTEGER, P_LOCAL, DEFAULT_OFFSET(iMaxPrintJobs), NULL, NULL, FLAG_PRINT},
+	{"printable", P_BOOL, P_LOCAL, DEFAULT_OFFSET(bPrint_ok), NULL, NULL, FLAG_PRINT},
+	{"print ok", P_BOOL, P_LOCAL, DEFAULT_OFFSET(bPrint_ok), NULL, NULL, FLAG_HIDE},
 	
-	{"printer name", P_STRING, P_LOCAL, &sDefault.szPrintername, NULL, NULL, FLAG_PRINT},
-	{"printer", P_STRING, P_LOCAL, &sDefault.szPrintername, NULL, NULL, FLAG_HIDE},
+	{"printer name", P_STRING, P_LOCAL, DEFAULT_OFFSET(szPrintername), NULL, NULL, FLAG_PRINT},
+	{"printer", P_STRING, P_LOCAL, DEFAULT_OFFSET(szPrintername), NULL, NULL, FLAG_HIDE},
 
 	{"Filename Handling", P_SEP, P_SEPARATOR},
 	
-	{"map system", P_BOOL, P_LOCAL, &sDefault.bMap_system, NULL, NULL, FLAG_SHARE | FLAG_GLOBAL},
-	{"map hidden", P_BOOL, P_LOCAL, &sDefault.bMap_hidden, NULL, NULL, FLAG_SHARE | FLAG_GLOBAL},
-	{"map archive", P_BOOL, P_LOCAL, &sDefault.bMap_archive, NULL, NULL, FLAG_SHARE | FLAG_GLOBAL},
+	{"map system", P_BOOL, P_LOCAL, DEFAULT_OFFSET(bMap_system), NULL, NULL, FLAG_SHARE | FLAG_GLOBAL},
+	{"map hidden", P_BOOL, P_LOCAL, DEFAULT_OFFSET(bMap_hidden), NULL, NULL, FLAG_SHARE | FLAG_GLOBAL},
+	{"map archive", P_BOOL, P_LOCAL, DEFAULT_OFFSET(bMap_archive), NULL, NULL, FLAG_SHARE | FLAG_GLOBAL},
 
 	{"Domain Options", P_SEP, P_SEPARATOR},
 	
@@ -503,56 +516,56 @@
 
 	{"Browse Options", P_SEP, P_SEPARATOR},
 	
-	{"preferred master", P_ENUM, P_GLOBAL, &Globals.bPreferredMaster, NULL, enum_bool_auto, FLAG_BASIC | FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"prefered master", P_ENUM, P_GLOBAL, &Globals.bPreferredMaster, NULL, enum_bool_auto, FLAG_HIDE},
-	{"local master", P_BOOL, P_GLOBAL, &Globals.bLocalMaster, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"browseable", P_BOOL, P_LOCAL, &sDefault.bBrowseable, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE | FLAG_PRINT | FLAG_DEVELOPER},
-	{"browsable", P_BOOL, P_LOCAL, &sDefault.bBrowseable, NULL, NULL, FLAG_HIDE},
+	{"preferred master", P_ENUM, P_GLOBAL, GLOBALS_OFFSET(bPreferredMaster), NULL, enum_bool_auto, FLAG_BASIC | FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"prefered master", P_ENUM, P_GLOBAL, GLOBALS_OFFSET(bPreferredMaster), NULL, enum_bool_auto, FLAG_HIDE},
+	{"local master", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bLocalMaster), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"browseable", P_BOOL, P_LOCAL, DEFAULT_OFFSET(bBrowseable), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE | FLAG_PRINT | FLAG_DEVELOPER},
+	{"browsable", P_BOOL, P_LOCAL, DEFAULT_OFFSET(bBrowseable), NULL, NULL, FLAG_HIDE},
 
 	{"WINS Options", P_SEP, P_SEPARATOR},
 	
-	{"wins server", P_LIST, P_GLOBAL, &Globals.szWINSservers, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"wins support", P_BOOL, P_GLOBAL, &Globals.bWINSsupport, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"dns proxy", P_BOOL, P_GLOBAL, &Globals.bWINSdnsProxy, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
-	{"wins hook", P_STRING, P_GLOBAL, &Globals.szWINSHook, NULL, NULL, FLAG_ADVANCED}, 
+	{"wins server", P_LIST, P_GLOBAL, GLOBALS_OFFSET(szWINSservers), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"wins support", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bWINSsupport), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"dns proxy", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bWINSdnsProxy), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_WIZARD | FLAG_DEVELOPER},
+	{"wins hook", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szWINSHook), NULL, NULL, FLAG_ADVANCED}, 
 
 	{"Locking Options", P_SEP, P_SEPARATOR},
 	
-	{"csc policy", P_ENUM, P_LOCAL, &sDefault.iCSCPolicy, NULL, enum_csc_policy, FLAG_SHARE | FLAG_GLOBAL},
+	{"csc policy", P_ENUM, P_LOCAL, DEFAULT_OFFSET(iCSCPolicy), NULL, enum_csc_policy, FLAG_SHARE | FLAG_GLOBAL},
 	
-	{"strict locking", P_BOOL, P_LOCAL, &sDefault.bStrictLocking, NULL, NULL, FLAG_SHARE | FLAG_GLOBAL},
+	{"strict locking", P_BOOL, P_LOCAL, DEFAULT_OFFSET(bStrictLocking), NULL, NULL, FLAG_SHARE | FLAG_GLOBAL},
 
 	{"Miscellaneous Options", P_SEP, P_SEPARATOR},
 	
-	{"config file", P_STRING, P_GLOBAL, &Globals.szConfigFile, NULL, NULL, FLAG_HIDE},
-	{"share backend", P_STRING, P_GLOBAL, &Globals.szShareBackend, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"preload", P_STRING, P_GLOBAL, &Globals.szAutoServices, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"auto services", P_STRING, P_GLOBAL, &Globals.szAutoServices, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"lock dir", P_STRING, P_GLOBAL, &Globals.szLockDir, NULL, NULL, FLAG_HIDE}, 
-	{"lock directory", P_STRING, P_GLOBAL, &Globals.szLockDir, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"modules dir", P_STRING, P_GLOBAL, &Globals.szModulesDir, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"pid directory", P_STRING, P_GLOBAL, &Globals.szPidDir, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER}, 
-	{"js include", P_LIST, P_GLOBAL, &Globals.jsInclude, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"jsonrpc services directory", P_STRING, P_GLOBAL, &Globals.jsonrpcServicesDir, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"setup directory", P_STRING, P_GLOBAL, &Globals.szSetupDir, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	
-	{"socket address", P_STRING, P_GLOBAL, &Globals.szSocketAddress, NULL, NULL, FLAG_DEVELOPER},
-	{"-valid", P_BOOL, P_LOCAL, &sDefault.valid, NULL, NULL, FLAG_HIDE},
-	
-	{"copy", P_STRING, P_LOCAL, &sDefault.szCopy, handle_copy, NULL, FLAG_HIDE},
-	{"include", P_STRING, P_LOCAL, &sDefault.szInclude, handle_include, NULL, FLAG_HIDE},
-	
-	{"available", P_BOOL, P_LOCAL, &sDefault.bAvailable, NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE | FLAG_PRINT},
-	{"volume", P_STRING, P_LOCAL, &sDefault.volume, NULL, NULL, FLAG_SHARE },
-	{"fstype", P_STRING, P_LOCAL, &sDefault.fstype, NULL, NULL, FLAG_SHARE},
+	{"config file", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szConfigFile), NULL, NULL, FLAG_HIDE},
+	{"share backend", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szShareBackend), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"preload", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szAutoServices), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"auto services", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szAutoServices), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"lock dir", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szLockDir), NULL, NULL, FLAG_HIDE}, 
+	{"lock directory", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szLockDir), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"modules dir", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szModulesDir), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"pid directory", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szPidDir), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER}, 
+	{"js include", P_LIST, P_GLOBAL, GLOBALS_OFFSET(jsInclude), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"jsonrpc services directory", P_STRING, P_GLOBAL, GLOBALS_OFFSET(jsonrpcServicesDir), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"setup directory", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szSetupDir), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	
+	{"socket address", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szSocketAddress), NULL, NULL, FLAG_DEVELOPER},
+	{"-valid", P_BOOL, P_LOCAL, DEFAULT_OFFSET(valid), NULL, NULL, FLAG_HIDE},
+	
+	{"copy", P_STRING, P_LOCAL, DEFAULT_OFFSET(szCopy), handle_copy, NULL, FLAG_HIDE},
+	{"include", P_STRING, P_LOCAL, DEFAULT_OFFSET(szInclude), handle_include, NULL, FLAG_HIDE},
+	
+	{"available", P_BOOL, P_LOCAL, DEFAULT_OFFSET(bAvailable), NULL, NULL, FLAG_BASIC | FLAG_ADVANCED | FLAG_SHARE | FLAG_PRINT},
+	{"volume", P_STRING, P_LOCAL, DEFAULT_OFFSET(volume), NULL, NULL, FLAG_SHARE },
+	{"fstype", P_STRING, P_LOCAL, DEFAULT_OFFSET(fstype), NULL, NULL, FLAG_SHARE},
 
 	{"panic action", P_STRING, P_GLOBAL, &panic_action, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
 
-	{"msdfs root", P_BOOL, P_LOCAL, &sDefault.bMSDfsRoot, NULL, NULL, FLAG_SHARE},
-	{"host msdfs", P_BOOL, P_GLOBAL, &Globals.bHostMSDfs, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
-	{"winbind separator", P_STRING, P_GLOBAL, &Globals.szWinbindSeparator, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER },
-	{"winbindd socket directory", P_STRING, P_GLOBAL, &Globals.szWinbinddSocketDirectory, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER },
-	{"winbind sealed pipes", P_BOOL, P_GLOBAL, &Globals.bWinbindSealedPipes, NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER },
+	{"msdfs root", P_BOOL, P_LOCAL, DEFAULT_OFFSET(bMSDfsRoot), NULL, NULL, FLAG_SHARE},
+	{"host msdfs", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bHostMSDfs), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER},
+	{"winbind separator", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szWinbindSeparator), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER },
+	{"winbindd socket directory", P_STRING, P_GLOBAL, GLOBALS_OFFSET(szWinbinddSocketDirectory), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER },
+	{"winbind sealed pipes", P_BOOL, P_GLOBAL, GLOBALS_OFFSET(bWinbindSealedPipes), NULL, NULL, FLAG_ADVANCED | FLAG_DEVELOPER },
 
 	{NULL, P_BOOL, P_NONE, NULL, NULL, NULL, 0}
 };
@@ -573,6 +586,7 @@
 {
 	int i;
 	char *myname;
+	struct loadparm_context *ctx = &global_params;
 
 	DEBUG(3, ("Initialising global parameters\n"));
 
@@ -585,132 +599,132 @@
 		}
 	}
 
-	do_parameter("config file", dyn_CONFIGFILE, NULL);
+	do_parameter(ctx, "config file", dyn_CONFIGFILE);
 
-	do_parameter("share backend", "classic", NULL);
+	do_parameter(ctx, "share backend", "classic");
 	
-	do_parameter("server role", "standalone", NULL);
+	do_parameter(ctx, "server role", "standalone");
 
 	/* options that can be set on the command line must be initialised via
-	   the slower do_parameter() to ensure that FLAG_CMDLINE is obeyed */
+	   the slower do_parameter(ctx, ) to ensure that FLAG_CMDLINE is obeyed */
 #ifdef TCP_NODELAY
-	do_parameter("socket options", "TCP_NODELAY", NULL);
+	do_parameter(ctx, "socket options", "TCP_NODELAY");
 #endif
-	do_parameter("workgroup", DEFAULT_WORKGROUP, NULL);
+	do_parameter(ctx, "workgroup", DEFAULT_WORKGROUP);
 	myname = get_myname();
-	do_parameter("netbios name", myname, NULL);
+	do_parameter(ctx, "netbios name", myname);
 	SAFE_FREE(myname);
-	do_parameter("name resolve order", "lmhosts wins host bcast", NULL);
-
-	do_parameter("fstype", FSTYPE_STRING, NULL);
-	do_parameter("ntvfs handler", "unixuid default", NULL);
-	do_parameter("max connections", "-1", NULL);
-
-	do_parameter("dcerpc endpoint servers", "epmapper srvsvc wkssvc rpcecho samr netlogon lsarpc spoolss drsuapi winreg dssetup unixinfo", NULL);
-	do_parameter("server services", "smb rpc nbt wrepl ldap cldap web kdc drepl winbind", NULL);
-	do_parameter("ntptr providor", "simple_ldb", NULL);
-	do_parameter("auth methods", "anonymous sam_ignoredomain", NULL);
-	do_parameter("private dir", dyn_PRIVATE_DIR, NULL);
-	do_parameter("sam database", "sam.ldb", NULL);
-	do_parameter("secrets database", "secrets.ldb", NULL);
-	do_parameter("spoolss database", "spoolss.ldb", NULL);
-	do_parameter("wins config database", "wins_config.ldb", NULL);
-	do_parameter("wins database", "wins.ldb", NULL);
-	do_parameter("registry:HKEY_LOCAL_MACHINE", "hklm.ldb", NULL);
+	do_parameter(ctx, "name resolve order", "lmhosts wins host bcast");
+
+	do_parameter(ctx, "fstype", FSTYPE_STRING);
+	do_parameter(ctx, "ntvfs handler", "unixuid default");
+	do_parameter(ctx, "max connections", "-1");
+
+	do_parameter(ctx, "dcerpc endpoint servers", "epmapper srvsvc wkssvc rpcecho samr netlogon lsarpc spoolss drsuapi winreg dssetup unixinfo");
+	do_parameter(ctx, "server services", "smb rpc nbt wrepl ldap cldap web kdc drepl winbind");
+	do_parameter(ctx, "ntptr providor", "simple_ldb");
+	do_parameter(ctx, "auth methods", "anonymous sam_ignoredomain");
+	do_parameter(ctx, "private dir", dyn_PRIVATE_DIR);
+	do_parameter(ctx, "sam database", "sam.ldb");
+	do_parameter(ctx, "secrets database", "secrets.ldb");
+	do_parameter(ctx, "spoolss database", "spoolss.ldb");
+	do_parameter(ctx, "wins config database", "wins_config.ldb");
+	do_parameter(ctx, "wins database", "wins.ldb");
+	do_parameter(ctx, "registry:HKEY_LOCAL_MACHINE", "hklm.ldb");
 
 	/* This hive should be dynamically generated by Samba using
 	   data from the sam, but for the moment leave it in a tdb to
 	   keep regedt32 from popping up an annoying dialog. */
-	do_parameter("registry:HKEY_USERS", "hku.ldb", NULL);
+	do_parameter(ctx, "registry:HKEY_USERS", "hku.ldb");
 	
 	/* using UTF8 by default allows us to support all chars */
-	do_parameter("unix charset", "UTF8", NULL);
+	do_parameter(ctx, "unix charset", "UTF8");
 
 	/* Use codepage 850 as a default for the dos character set */
-	do_parameter("dos charset", "CP850", NULL);
+	do_parameter(ctx, "dos charset", "CP850");
 
 	/*
 	 * Allow the default PASSWD_CHAT to be overridden in local.h.
 	 */
-	do_parameter("passwd chat", DEFAULT_PASSWD_CHAT, NULL);
-
-	do_parameter("pid directory", dyn_PIDDIR, NULL);
-	do_parameter("lock dir", dyn_LOCKDIR, NULL);
-	do_parameter("modules dir", dyn_MODULESDIR, NULL);
-	do_parameter("ncalrpc dir", dyn_NCALRPCDIR, NULL);
-
-	do_parameter("socket address", "0.0.0.0", NULL);
-	do_parameter_var("server string", "Samba %s", SAMBA_VERSION_STRING);
-
-	do_parameter_var("announce version", "%d.%d", 
+	do_parameter(ctx, "passwd chat", DEFAULT_PASSWD_CHAT);
+
+	do_parameter(ctx, "pid directory", dyn_PIDDIR);
+	do_parameter(ctx, "lock dir", dyn_LOCKDIR);
+	do_parameter(ctx, "modules dir", dyn_MODULESDIR);
+	do_parameter(ctx, "ncalrpc dir", dyn_NCALRPCDIR);
+
+	do_parameter(ctx, "socket address", "0.0.0.0");
+	do_parameter_var(ctx, "server string", "Samba %s", SAMBA_VERSION_STRING);
+
+	do_parameter_var(ctx, "announce version", "%d.%d", 
 			 DEFAULT_MAJOR_VERSION,
 			 DEFAULT_MINOR_VERSION);
 
-	do_parameter("password server", "*", NULL);
-
-	do_parameter("max mux", "50", NULL);
-	do_parameter("max xmit", "12288", NULL);
-	do_parameter("password level", "0", NULL);
-	do_parameter("LargeReadwrite", "True", NULL);
-	do_parameter("server min protocol", "CORE", NULL);
-	do_parameter("server max protocol", "NT1", NULL);
-	do_parameter("client min protocol", "CORE", NULL);
-	do_parameter("client max protocol", "NT1", NULL);
-	do_parameter("security", "USER", NULL);
-	do_parameter("paranoid server security", "True", NULL);
-	do_parameter("EncryptPasswords", "True", NULL);
-	do_parameter("ReadRaw", "True", NULL);
-	do_parameter("WriteRaw", "True", NULL);
-	do_parameter("NullPasswords", "False", NULL);
-	do_parameter("ObeyPamRestrictions", "False", NULL);
-	do_parameter("announce as", "NT SERVER", NULL);
-
-	do_parameter("TimeServer", "False", NULL);
-	do_parameter("BindInterfacesOnly", "False", NULL);
-	do_parameter("Unicode", "True", NULL);
-	do_parameter("ClientLanManAuth", "True", NULL);
-	do_parameter("LanmanAuth", "True", NULL);
-	do_parameter("NTLMAuth", "True", NULL);
-	do_parameter("client use spnego principal", "False", NULL);
+	do_parameter(ctx, "password server", "*");
+
+	do_parameter(ctx, "max mux", "50");
+	do_parameter(ctx, "max xmit", "12288");
+	do_parameter(ctx, "password level", "0");
+	do_parameter(ctx, "LargeReadwrite", "True");
+	do_parameter(ctx, "server min protocol", "CORE");
+	do_parameter(ctx, "server max protocol", "NT1");
+	do_parameter(ctx, "client min protocol", "CORE");
+	do_parameter(ctx, "client max protocol", "NT1");
+	do_parameter(ctx, "security", "USER");
+	do_parameter(ctx, "paranoid server security", "True");
+	do_parameter(ctx, "EncryptPasswords", "True");
+	do_parameter(ctx, "ReadRaw", "True");
+	do_parameter(ctx, "WriteRaw", "True");
+	do_parameter(ctx, "NullPasswords", "False");
+	do_parameter(ctx, "ObeyPamRestrictions", "False");
+	do_parameter(ctx, "announce as", "NT SERVER");
+
+	do_parameter(ctx, "TimeServer", "False");
+	do_parameter(ctx, "BindInterfacesOnly", "False");
+	do_parameter(ctx, "Unicode", "True");
+	do_parameter(ctx, "ClientLanManAuth", "True");
+	do_parameter(ctx, "LanmanAuth", "True");
+	do_parameter(ctx, "NTLMAuth", "True");
+	do_parameter(ctx, "client use spnego principal", "False");
 	
-	do_parameter("UnixExtensions", "False", NULL);
-
-	do_parameter("PreferredMaster", "Auto", NULL);
-	do_parameter("LocalMaster", "True", NULL);
-
-	do_parameter("wins support", "False", NULL);
-	do_parameter("dns proxy", "True", NULL);
-
-	do_parameter("winbind separator", "\\", NULL);
-	do_parameter("winbind sealed pipes", "True", NULL);
-	do_parameter("winbindd socket directory", dyn_WINBINDD_SOCKET_DIR, NULL);
-
-	do_parameter("client signing", "Yes", NULL);
-	do_parameter("server signing", "auto", NULL);
-
-	do_parameter("use spnego", "True", NULL);
-
-	do_parameter("smb ports", "445 139", NULL);
-	do_parameter("nbt port", "137", NULL);
-	do_parameter("dgram port", "138", NULL);
-	do_parameter("cldap port", "389", NULL);
-	do_parameter("krb5 port", "88", NULL);
-	do_parameter("kpasswd port", "464", NULL);
-	do_parameter("web port", "901", NULL);
-	do_parameter("web application directory", dyn_WEBAPPSDIR, NULL);
-	do_parameter("jsonrpc services directory", dyn_SERVICESDIR, NULL);
-
-	do_parameter("nt status support", "True", NULL);
-
-	do_parameter("max wins ttl", "518400", NULL); /* 6 days */
-	do_parameter("min wins ttl", "10", NULL);
-
-	do_parameter("tls enabled", "True", NULL);
-	do_parameter("tls keyfile", "tls/key.pem", NULL);
-	do_parameter("tls certfile", "tls/cert.pem", NULL);
-	do_parameter("tls cafile", "tls/ca.pem", NULL);
-	do_parameter_var("js include", "%s", dyn_JSDIR);
-	do_parameter_var("setup directory", "%s", dyn_SETUPDIR);
+	do_parameter(ctx, "UnixExtensions", "False");
+
+	do_parameter(ctx, "PreferredMaster", "Auto");
+	do_parameter(ctx, "LocalMaster", "True");
+
+	do_parameter(ctx, "wins support", "False");
+	do_parameter(ctx, "dns proxy", "True");
+
+	do_parameter(ctx, "winbind separator", "\\");
+	do_parameter(ctx, "winbind sealed pipes", "True");
+	do_parameter(ctx, "winbindd socket directory", dyn_WINBINDD_SOCKET_DIR);
+
+	do_parameter(ctx, "client signing", "Yes");
+	do_parameter(ctx, "server signing", "auto");
+
+	do_parameter(ctx, "use spnego", "True");
+
+	do_parameter(ctx, "smb ports", "445 139");
+	do_parameter(ctx, "nbt port", "137");
+	do_parameter(ctx, "dgram port", "138");
+	do_parameter(ctx, "cldap port", "389");
+	do_parameter(ctx, "krb5 port", "88");
+	do_parameter(ctx, "kpasswd port", "464");
+	do_parameter(ctx, "web port", "901");
+	do_parameter(ctx, "web application directory", dyn_WEBAPPSDIR);
+	do_parameter(ctx, "jsonrpc services directory", dyn_SERVICESDIR);
+
+	do_parameter(ctx, "nt status support", "True");
+
+	do_parameter(ctx, "max wins ttl", "518400"); /* 6 days */
+	do_parameter(ctx, "min wins ttl", "10");
+
+	do_parameter(ctx, "tls enabled", "True");
+	do_parameter(ctx, "tls keyfile", "tls/key.pem");
+	do_parameter(ctx, "tls certfile", "tls/cert.pem");
+	do_parameter(ctx, "tls cafile", "tls/ca.pem");
+	do_parameter_var(ctx, "js include", "%s", dyn_JSDIR);
+	do_parameter_var(ctx, "setup directory", "%s", dyn_SETUPDIR);
 
 	for (i = 0; parm_table[i].label; i++) {
 		if (!(parm_table[i].flags & FLAG_CMDLINE)) {
@@ -801,19 +815,19 @@
  int fn_name(void) {return(*(int *)(ptr));}
 
 #define FN_LOCAL_STRING(fn_name,val) \
- const char *fn_name(int i) {return(lp_string((LP_SNUM_OK(i) && ServicePtrs[(i)]->val) ? ServicePtrs[(i)]->val : sDefault.val));}
+ const char *fn_name(int i) {return(lp_string((LP_SNUM_OK(i) && global_params.ServicePtrs[(i)]->val) ? global_params.ServicePtrs[(i)]->val : sDefault.val));}
 #define FN_LOCAL_CONST_STRING(fn_name,val) \
- const char *fn_name(int i) {return (const char *)((LP_SNUM_OK(i) && ServicePtrs[(i)]->val) ? ServicePtrs[(i)]->val : sDefault.val);}
+ const char *fn_name(int i) {return (const char *)((LP_SNUM_OK(i) && global_params.ServicePtrs[(i)]->val) ? global_params.ServicePtrs[(i)]->val : sDefault.val);}
 #define FN_LOCAL_LIST(fn_name,val) \
- const char **fn_name(int i) {return(const char **)(LP_SNUM_OK(i)? ServicePtrs[(i)]->val : sDefault.val);}
+ const char **fn_name(int i) {return(const char **)(LP_SNUM_OK(i)? global_params.ServicePtrs[(i)]->val : sDefault.val);}
 #define FN_LOCAL_BOOL(fn_name,val) \
- BOOL fn_name(int i) {return(LP_SNUM_OK(i)? ServicePtrs[(i)]->val : sDefault.val);}
+ BOOL fn_name(int i) {return(LP_SNUM_OK(i)? global_params.ServicePtrs[(i)]->val : sDefault.val);}
 #if 0 /* unused */
 #define FN_LOCAL_CHAR(fn_name,val) \
- char fn_name(int i) {return(LP_SNUM_OK(i)? ServicePtrs[(i)]->val : sDefault.val);}
+ char fn_name(int i) {return(LP_SNUM_OK(i)? global_params.ServicePtrs[(i)]->val : sDefault.val);}
 #endif
 #define FN_LOCAL_INTEGER(fn_name,val) \
- int fn_name(int i) {return(LP_SNUM_OK(i)? ServicePtrs[(i)]->val : sDefault.val);}
+ int fn_name(int i) {return(LP_SNUM_OK(i)? global_params.ServicePtrs[(i)]->val : sDefault.val);}
 
 _PUBLIC_ FN_GLOBAL_INTEGER(lp_server_role, &Globals.server_role)
 _PUBLIC_ FN_GLOBAL_LIST(lp_smb_ports, &Globals.smb_ports)
@@ -907,8 +921,6 @@
 _PUBLIC_ FN_GLOBAL_INTEGER(lp_announce_as, &Globals.announce_as)
 _PUBLIC_ FN_GLOBAL_LIST(lp_js_include, &Globals.jsInclude)
 _PUBLIC_ FN_GLOBAL_STRING(lp_jsonrpc_services_dir, &Globals.jsonrpcServicesDir)
-_PUBLIC_ 
-_PUBLIC_ 
 _PUBLIC_ FN_LOCAL_STRING(lp_servicename, szService)
 _PUBLIC_ FN_LOCAL_CONST_STRING(lp_const_servicename, szService)
 _PUBLIC_ FN_LOCAL_STRING(lp_pathname, szPath)
@@ -937,26 +949,31 @@
 /* local prototypes */
 
 static int map_parameter(const char *pszParmName);
-static int getservicebyname(const char *pszServiceName,
-			    service * pserviceDest);
+static int getservicebyname(struct loadparm_context *ctx, 
+							const char *pszServiceName,
+							service * pserviceDest);
 static void copy_service(service * pserviceDest,
 			 service * pserviceSource, int *pcopymapDest);
-static BOOL service_ok(int iService);
-static BOOL do_section(const char *pszSectionName, void *);
+static BOOL service_ok(struct loadparm_context *ctx, int iService);
+static BOOL parse_section(const char *pszSectionName, void *);
+static BOOL parse_parameter(const char *, const char *, void *);
 static void init_copymap(service * pservice);
 
 /* This is a helper function for parametrical options support. */
 /* It returns a pointer to parametrical option value if it exists or NULL otherwise */
 /* Actual parametrical functions are quite simple */
-const char *lp_get_parametric(int lookup_service, const char *type, const char *option)
+const char *lp_get_parametric(struct loadparm_context *ctx, 
+							  int lookup_service, const char *type, 
+							  const char *option)
 {
 	char *vfskey;
         struct param_opt *data;
 	
-	if (lookup_service >= iNumServices) return NULL;
+	if (lookup_service >= ctx->iNumServices) 
+		return NULL;
 	
 	data = (lookup_service < 0) ? 
-		Globals.param_opt : ServicePtrs[lookup_service]->param_opt;
+		Globals.param_opt : ctx->ServicePtrs[lookup_service]->param_opt;
     
 	asprintf(&vfskey, "%s:%s", type, option);
 	strlower(vfskey);
@@ -1021,7 +1038,7 @@
 ********************************************************************/
 static BOOL lp_bool(const char *s)
 {
-	BOOL ret = False;
+	BOOL ret = false;
 
 	if (!s) {
 		DEBUG(0,("lp_bool(%s): is called with NULL!\n",s));
@@ -1043,7 +1060,8 @@
 
 const char *lp_parm_string(int lookup_service, const char *type, const char *option)
 {
-	const char *value = lp_get_parametric(lookup_service, type, option);
+	const char *value = lp_get_parametric(&global_params, 
+										  lookup_service, type, option);
 
 	if (value)
 		return lp_string(value);
@@ -1058,7 +1076,7 @@
 const char **lp_parm_string_list(int lookup_service, const char *type, const char *option,
 				 const char *separator)
 {
-	const char *value = lp_get_parametric(lookup_service, type, option);
+	const char *value = lp_get_parametric(&global_params, lookup_service, type, option);
 	
 	if (value)
 		return str_list_make(talloc_autofree_context(), value, separator);
@@ -1071,7 +1089,8 @@
 
 int lp_parm_int(int lookup_service, const char *type, const char *option, int default_v)
 {
-	const char *value = lp_get_parametric(lookup_service, type, option);
+	const char *value = lp_get_parametric(&global_params, 
+										  lookup_service, type, option);
 	
 	if (value)
 		return lp_int(value);
@@ -1084,11 +1103,13 @@
  * Parametric option has following syntax: 'Type: option = value'.
  */
 
-int lp_parm_bytes(int lookup_service, const char *type, const char *option, int default_v)
+int lp_parm_bytes(int lookup_service, const char *type, const char *option, 
+				  int default_v)
 {
 	uint64_t bval;
 
-	const char *value = lp_get_parametric(lookup_service, type, option);
+	const char *value = lp_get_parametric(&global_params, 
+										  lookup_service, type, option);
 
 	if (value && conv_str_size(value, &bval)) {
 		if (bval <= INT_MAX) {
@@ -1104,7 +1125,8 @@
 
 unsigned long lp_parm_ulong(int lookup_service, const char *type, const char *option, unsigned long default_v)
 {
-	const char *value = lp_get_parametric(lookup_service, type, option);
+	const char *value = lp_get_parametric(&global_params, 
+										  lookup_service, type, option);
 	
 	if (value)
 		return lp_ulong(value);
@@ -1117,7 +1139,8 @@
 
 BOOL lp_parm_bool(int lookup_service, const char *type, const char *option, BOOL default_v)
 {
-	const char *value = lp_get_parametric(lookup_service, type, option);
+	const char *value = lp_get_parametric(&global_params, 
+										  lookup_service, type, option);
 	
 	if (value)
 		return lp_bool(value);
@@ -1189,22 +1212,23 @@
  service. 
 ***************************************************************************/
 
-static int add_a_service(const service *pservice, const char *name)
+static int add_a_service(struct loadparm_context *ctx, 
+						 const service *pservice, const char *name)
 {
 	int i;
 	service tservice;
-	int num_to_alloc = iNumServices + 1;
+	int num_to_alloc = ctx->iNumServices + 1;
 	struct param_opt *data, *pdata;
 
 	tservice = *pservice;
 
 	/* it might already exist */
 	if (name) {
-		i = getservicebyname(name, NULL);
+		i = getservicebyname(ctx, name, NULL);
 		if (i >= 0) {
 			/* Clean all parametric options for service */
 			/* They will be added during parsing again */
-			data = ServicePtrs[i]->param_opt;
+			data = ctx->ServicePtrs[i]->param_opt;
 			while (data) {
 				string_free(&data->key);
 				string_free(&data->value);
@@ -1212,45 +1236,45 @@
 				SAFE_FREE(data);
 				data = pdata;
 			}
-			ServicePtrs[i]->param_opt = NULL;
+			ctx->ServicePtrs[i]->param_opt = NULL;
 			return (i);
 		}
 	}
 
 	/* find an invalid one */
-	for (i = 0; i < iNumServices; i++)
-		if (!ServicePtrs[i]->valid)
+	for (i = 0; i < ctx->iNumServices; i++)
+		if (!ctx->ServicePtrs[i]->valid)
 			break;
 
 	/* if not, then create one */
-	if (i == iNumServices) {
+	if (i == ctx->iNumServices) {
 		service **tsp;
 		
-		tsp = realloc_p(ServicePtrs, service *,	num_to_alloc);
+		tsp = realloc_p(ctx->ServicePtrs, service *,	num_to_alloc);
 					   
 		if (!tsp) {
 			DEBUG(0,("add_a_service: failed to enlarge ServicePtrs!\n"));
 			return (-1);
 		}
 		else {
-			ServicePtrs = tsp;
-			ServicePtrs[iNumServices] = malloc_p(service);
+			ctx->ServicePtrs = tsp;
+			ctx->ServicePtrs[ctx->iNumServices] = malloc_p(service);
 		}
-		if (!ServicePtrs[iNumServices]) {
+		if (!ctx->ServicePtrs[ctx->iNumServices]) {
 			DEBUG(0,("add_a_service: out of memory!\n"));
 			return (-1);
 		}
 
-		iNumServices++;
+		ctx->iNumServices++;
 	} else
-		free_service(ServicePtrs[i]);
-
-	ServicePtrs[i]->valid = True;
-
-	init_service(ServicePtrs[i]);
-	copy_service(ServicePtrs[i], &tservice, NULL);
+		free_service(ctx->ServicePtrs[i]);
+
+	ctx->ServicePtrs[i]->valid = true;
+
+	init_service(ctx->ServicePtrs[i]);
+	copy_service(ctx->ServicePtrs[i], &tservice, NULL);
 	if (name)
-		string_set(&ServicePtrs[i]->szService, name);
+		string_set(&ctx->ServicePtrs[i]->szService, name);
 	return (i);
 }
 
@@ -1259,35 +1283,36 @@
  from service ifrom.
 ***************************************************************************/
 
-BOOL lp_add_home(const char *pszHomename, int iDefaultService, 
-		 const char *user, const char *pszHomedir)
+BOOL lp_add_home(struct loadparm_context *ctx, 
+				 const char *pszHomename, int iDefaultService, 
+				 const char *user, const char *pszHomedir)
 {
 	int i;
 	pstring newHomedir;
 
-	i = add_a_service(ServicePtrs[iDefaultService], pszHomename);
+	i = add_a_service(ctx, ctx->ServicePtrs[iDefaultService], pszHomename);
 
 	if (i < 0)
 		return (False);
 
-	if (!(*(ServicePtrs[iDefaultService]->szPath))
-	    || strequal(ServicePtrs[iDefaultService]->szPath, lp_pathname(-1))) {
+	if (!(*(ctx->ServicePtrs[iDefaultService]->szPath))
+	    || strequal(ctx->ServicePtrs[iDefaultService]->szPath, lp_pathname(-1))) {
 		pstrcpy(newHomedir, pszHomedir);
 	} else {
 		pstrcpy(newHomedir, lp_pathname(iDefaultService));
 		string_sub(newHomedir,"%H", pszHomedir, sizeof(newHomedir)); 
 	}
 
-	string_set(&ServicePtrs[i]->szPath, newHomedir);
+	string_set(&ctx->ServicePtrs[i]->szPath, newHomedir);
 
-	if (!(*(ServicePtrs[i]->comment))) {
+	if (!(*(ctx->ServicePtrs[i]->comment))) {
 		pstring comment;
 		slprintf(comment, sizeof(comment) - 1,
 			 "Home directory of %s", user);
-		string_set(&ServicePtrs[i]->comment, comment);
+		string_set(&ctx->ServicePtrs[i]->comment, comment);
 	}
-	ServicePtrs[i]->bAvailable = sDefault.bAvailable;
-	ServicePtrs[i]->bBrowseable = sDefault.bBrowseable;
+	ctx->ServicePtrs[i]->bAvailable = sDefault.bAvailable;
+	ctx->ServicePtrs[i]->bBrowseable = sDefault.bBrowseable;
 
 	DEBUG(3, ("adding home's share [%s] for user '%s' at '%s'\n", pszHomename, 
 	       user, newHomedir));
@@ -1299,19 +1324,21 @@
  Add a new service, based on an old one.
 ***************************************************************************/
 
-int lp_add_service(const char *pszService, int iDefaultService)
+int lp_add_service(struct loadparm_context *ctx, 
+				   const char *pszService, int iDefaultService)
 {
-	return (add_a_service(ServicePtrs[iDefaultService], pszService));
+	return (add_a_service(ctx, ctx->ServicePtrs[iDefaultService], pszService));
 }
 
 /***************************************************************************
  Add the IPC service.
 ***************************************************************************/
 
-static BOOL lp_add_hidden(const char *name, const char *fstype)
+static BOOL lp_add_hidden(struct loadparm_context *ctx, 
+						  const char *name, const char *fstype)
 {
 	pstring comment;
-	int i = add_a_service(&sDefault, name);
+	int i = add_a_service(ctx, &sDefault, name);
 
 	if (i < 0)
 		return (False);
@@ -1319,17 +1346,17 @@
 	slprintf(comment, sizeof(comment) - 1,
 		 "%s Service (%s)", fstype, Globals.szServerString);
 
-	string_set(&ServicePtrs[i]->szPath, tmpdir());
-	string_set(&ServicePtrs[i]->comment, comment);
-	string_set(&ServicePtrs[i]->fstype, fstype);
-	ServicePtrs[i]->iMaxConnections = -1;
-	ServicePtrs[i]->bAvailable = True;
-	ServicePtrs[i]->bRead_only = True;
-	ServicePtrs[i]->bPrint_ok = False;
-	ServicePtrs[i]->bBrowseable = False;
+	string_set(&ctx->ServicePtrs[i]->szPath, tmpdir());
+	string_set(&ctx->ServicePtrs[i]->comment, comment);
+	string_set(&ctx->ServicePtrs[i]->fstype, fstype);
+	ctx->ServicePtrs[i]->iMaxConnections = -1;
+	ctx->ServicePtrs[i]->bAvailable = true;
+	ctx->ServicePtrs[i]->bRead_only = true;
+	ctx->ServicePtrs[i]->bPrint_ok = false;
+	ctx->ServicePtrs[i]->bBrowseable = false;
 
 	if (strcasecmp(fstype, "IPC") == 0) {
-		lp_do_parameter(i, "ntvfs handler", "default");
+		lp_do_parameter(ctx, i, "ntvfs handler", "default");
 	}
 
 	DEBUG(3, ("adding hidden service %s\n", name));
@@ -1341,10 +1368,11 @@
  Add a new printer service, with defaults coming from service iFrom.
 ***************************************************************************/
 
-BOOL lp_add_printer(const char *pszPrintername, int iDefaultService)
+BOOL lp_add_printer(struct loadparm_context *ctx, 
+					const char *pszPrintername, int iDefaultService)
 {
 	const char *comment = "From Printcap";
-	int i = add_a_service(ServicePtrs[iDefaultService], pszPrintername);
+	int i = add_a_service(ctx, ctx->ServicePtrs[iDefaultService], pszPrintername);
 
 	if (i < 0)
 		return (False);
@@ -1355,13 +1383,13 @@
 	/* entry (if/when the 'available' keyword is implemented!).    */
 
 	/* the printer name is set to the service name. */
-	string_set(&ServicePtrs[i]->szPrintername, pszPrintername);
-	string_set(&ServicePtrs[i]->comment, comment);
-	ServicePtrs[i]->bBrowseable = sDefault.bBrowseable;
+	string_set(&ctx->ServicePtrs[i]->szPrintername, pszPrintername);
+	string_set(&ctx->ServicePtrs[i]->comment, comment);
+	ctx->ServicePtrs[i]->bBrowseable = sDefault.bBrowseable;
 	/* Printers cannot be read_only. */
-	ServicePtrs[i]->bRead_only = False;
+	ctx->ServicePtrs[i]->bRead_only = false;
 	/* Printer services must be printable. */
-	ServicePtrs[i]->bPrint_ok = True;
+	ctx->ServicePtrs[i]->bPrint_ok = true;
 
 	DEBUG(3, ("adding printer service %s\n", pszPrintername));
 
@@ -1407,27 +1435,29 @@
 /*
   return the parameter pointer for a parameter
 */
-void *lp_parm_ptr(int snum, struct parm_struct *parm)
+void *lp_parm_ptr(struct loadparm_context *ctx, 
+				  int snum, struct parm_struct *parm)
 {
 	if (snum == -1) {
 		return parm->ptr;
 	}
-	return ((char *)ServicePtrs[snum]) + PTR_DIFF(parm->ptr, &sDefault);
+	return ((char *)ctx->ServicePtrs[snum]) + PTR_DIFF(parm->ptr, &sDefault);
 }
 
 /***************************************************************************
 Find a service by name. Otherwise works like get_service.
 ***************************************************************************/
 
-static int getservicebyname(const char *pszServiceName, service * pserviceDest)
+static int getservicebyname(struct loadparm_context *ctx, 
+							const char *pszServiceName, service * pserviceDest)
 {
 	int iService;
 
-	for (iService = iNumServices - 1; iService >= 0; iService--)
+	for (iService = ctx->iNumServices - 1; iService >= 0; iService--)
 		if (VALID(iService) &&
-		    strwicmp(ServicePtrs[iService]->szService, pszServiceName) == 0) {
+		    strwicmp(ctx->ServicePtrs[iService]->szService, pszServiceName) == 0) {
 			if (pserviceDest != NULL)
-				copy_service(pserviceDest, ServicePtrs[iService], NULL);
+				copy_service(pserviceDest, ctx->ServicePtrs[iService], NULL);
 			break;
 		}
 
@@ -1496,7 +1526,7 @@
 	
 	data = pserviceSource->param_opt;
 	while (data) {
-		not_added = True;
+		not_added = true;
 		pdata = pserviceDest->param_opt;
 		/* Traverse destination */
 		while (pdata) {
@@ -1504,7 +1534,7 @@
 			if (strcmp(pdata->key, data->key) == 0) {
 				string_free(&pdata->value);
 				pdata->value = strdup(data->value);
-				not_added = False;
+				not_added = false;
 				break;
 			}
 			pdata = pdata->next;
@@ -1526,34 +1556,34 @@
 incomplete or faulty, else True.
 ***************************************************************************/
 
-static BOOL service_ok(int iService)
+static BOOL service_ok(struct loadparm_context *ctx, int iService)
 {
 	BOOL bRetval;
 
-	bRetval = True;
-	if (ServicePtrs[iService]->szService[0] == '\0') {
+	bRetval = true;
+	if (ctx->ServicePtrs[iService]->szService[0] == '\0') {
 		DEBUG(0, ("The following message indicates an internal error:\n"));
 		DEBUG(0, ("No service name in service entry.\n"));
-		bRetval = False;
+		bRetval = false;
 	}
 
 	/* The [printers] entry MUST be printable. I'm all for flexibility, but */
 	/* I can't see why you'd want a non-printable printer service...        */
-	if (strwicmp(ServicePtrs[iService]->szService, PRINTERS_NAME) == 0) {
-		if (!ServicePtrs[iService]->bPrint_ok) {
+	if (strwicmp(ctx->ServicePtrs[iService]->szService, PRINTERS_NAME) == 0) {
+		if (!ctx->ServicePtrs[iService]->bPrint_ok) {
 			DEBUG(0, ("WARNING: [%s] service MUST be printable!\n",
-			       ServicePtrs[iService]->szService));
-			ServicePtrs[iService]->bPrint_ok = True;
+			       ctx->ServicePtrs[iService]->szService));
+			ctx->ServicePtrs[iService]->bPrint_ok = true;
 		}
 		/* [printers] service must also be non-browsable. */
-		if (ServicePtrs[iService]->bBrowseable)
-			ServicePtrs[iService]->bBrowseable = False;
+		if (ctx->ServicePtrs[iService]->bBrowseable)
+			ctx->ServicePtrs[iService]->bBrowseable = false;
 	}
 
 	/* If a service is flagged unavailable, log the fact at level 0. */
-	if (!ServicePtrs[iService]->bAvailable)
+	if (!ctx->ServicePtrs[iService]->bAvailable)
 		DEBUG(1, ("NOTE: Service %s is flagged unavailable.\n",
-			  ServicePtrs[iService]->szService));
+			  ctx->ServicePtrs[iService]->szService));
 
 	return (bRetval);
 }
@@ -1643,7 +1673,8 @@
  Handle the include operation.
 ***************************************************************************/
 
-static BOOL handle_include(const char *pszParmValue, char **ptr)
+static BOOL handle_include(struct loadparm_context *ctx, 
+						   const char *pszParmValue, char **ptr)
 {
 	pstring fname;
 	pstrcpy(fname, pszParmValue);
@@ -1655,7 +1686,7 @@
 	string_set(ptr, fname);
 
 	if (file_exist(fname))
-		return (pm_process(fname, do_section, do_parameter, NULL));
+		return (pm_process(fname, parse_section, parse_parameter, ctx));
 
 	DEBUG(2, ("Can't find include file %s\n", fname));
 
@@ -1666,7 +1697,8 @@
  Handle the interpretation of the copy parameter.
 ***************************************************************************/
 
-static BOOL handle_copy(const char *pszParmValue, char **ptr)
+static BOOL handle_copy(struct loadparm_context *ctx, 
+						const char *pszParmValue, char **ptr)
 {
 	BOOL bRetval;
 	int iTemp;
@@ -1676,22 +1708,22 @@
 
 	init_service(&serviceTemp);
 
-	bRetval = False;
+	bRetval = false;
 
 	DEBUG(3, ("Copying service from service %s\n", pszParmValue));
 
-	if ((iTemp = getservicebyname(pszParmValue, &serviceTemp)) >= 0) {
+	if ((iTemp = getservicebyname(ctx, pszParmValue, &serviceTemp)) >= 0) {
 		if (iTemp == iServiceIndex) {
 			DEBUG(0, ("Can't copy service %s - unable to copy self!\n", pszParmValue));
 		} else {
-			copy_service(ServicePtrs[iServiceIndex],
+			copy_service(ctx->ServicePtrs[iServiceIndex],
 				     &serviceTemp,
-				     ServicePtrs[iServiceIndex]->copymap);
-			bRetval = True;
+				     ctx->ServicePtrs[iServiceIndex]->copymap);
+			bRetval = true;
 		}
 	} else {
 		DEBUG(0, ("Unable to copy service - source not found: %s\n", pszParmValue));
-		bRetval = False;
+		bRetval = false;
 	}
 
 	free_service(&serviceTemp);
@@ -1713,7 +1745,7 @@
 		       (int)NUMPARAMETERS));
 	else
 		for (i = 0; i < NUMPARAMETERS; i++)
-			pservice->copymap[i] = True;
+			pservice->copymap[i] = true;
 }
 
 #if 0 /* not used anywhere */
@@ -1731,7 +1763,9 @@
 /***************************************************************************
  Process a parametric option
 ***************************************************************************/
-static BOOL lp_do_parameter_parametric(int snum, const char *pszParmName, const char *pszParmValue, int flags)
+static BOOL lp_do_parameter_parametric(struct loadparm_context *ctx, 
+									   int snum, const char *pszParmName, 
+									   const char *pszParmValue, int flags)
 {
 	struct param_opt *paramo, *data;
 	char *name;
@@ -1748,7 +1782,7 @@
 	if (snum < 0) {
 		data = Globals.param_opt;
 	} else {
-		data = ServicePtrs[snum]->param_opt;
+		data = ctx->ServicePtrs[snum]->param_opt;
 	}
 
 	/* Traverse destination */
@@ -1778,7 +1812,7 @@
 	if (snum < 0) {
 		DLIST_ADD(Globals.param_opt, paramo);
 	} else {
-		DLIST_ADD(ServicePtrs[snum]->param_opt, paramo);
+		DLIST_ADD(ctx->ServicePtrs[snum]->param_opt, paramo);
 	}
 
 	free(name);
@@ -1790,7 +1824,8 @@
  Process a parameter for a particular service number. If snum < 0
  then assume we are in the globals.
 ***************************************************************************/
-BOOL lp_do_parameter(int snum, const char *pszParmName, const char *pszParmValue)
+BOOL lp_do_parameter(struct loadparm_context *ctx, int snum, 
+					 const char *pszParmName, const char *pszParmValue)
 {
 	int parmnum, i;
 	void *parm_ptr = NULL;	/* where we are going to store the result */
@@ -1800,7 +1835,7 @@
 
 	if (parmnum < 0) {
 		if (strchr(pszParmName, ':')) {
-			return lp_do_parameter_parametric(snum, pszParmName, pszParmValue, 0);
+			return lp_do_parameter_parametric(ctx, snum, pszParmName, pszParmValue, 0);
 		}
 		DEBUG(0, ("Ignoring unknown parameter \"%s\"\n", pszParmName));
 		return (True);
@@ -1830,24 +1865,24 @@
 			return (True);
 		}
 		parm_ptr =
-			((char *)ServicePtrs[snum]) + PTR_DIFF(def_ptr,
+			((char *)ctx->ServicePtrs[snum]) + PTR_DIFF(def_ptr,
 							    &sDefault);
 	}
 
 	if (snum >= 0) {
-		if (!ServicePtrs[snum]->copymap)
-			init_copymap(ServicePtrs[snum]);
+		if (!ctx->ServicePtrs[snum]->copymap)
+			init_copymap(ctx->ServicePtrs[snum]);
 
 		/* this handles the aliases - set the copymap for other entries with
 		   the same data pointer */
 		for (i = 0; parm_table[i].label; i++)
 			if (parm_table[i].ptr == parm_table[parmnum].ptr)
-				ServicePtrs[snum]->copymap[i] = False;
+				ctx->ServicePtrs[snum]->copymap[i] = false;
 	}
 
 	/* if it is a special case then go ahead */
 	if (parm_table[parmnum].special) {
-		parm_table[parmnum].special(pszParmValue, (char **)parm_ptr);
+		parm_table[parmnum].special(ctx, pszParmValue, (char **)parm_ptr);
 		return (True);
 	}
 
@@ -1936,18 +1971,28 @@
  Process a parameter.
 ***************************************************************************/
 
-static BOOL do_parameter(const char *pszParmName, const char *pszParmValue, void *userdata)
+static BOOL do_parameter(struct loadparm_context *ctx, 
+						 const char *pszParmName, const char *pszParmValue)
 {
-	return (lp_do_parameter(bInGlobalSection ? -2 : iServiceIndex,
+	return (lp_do_parameter(ctx, bInGlobalSection ? -2 : iServiceIndex,
 				pszParmName, pszParmValue));
 }
 
+static BOOL parse_parameter(const char *pszParmName, const char *pszParmValue, 
+						 void *userdata)
+{
+	struct loadparm_context *ctx = userdata;
+	return do_parameter(ctx, pszParmName, pszParmValue);
+}
+
+
+
 /*
   variable argument do parameter
 */
-static BOOL do_parameter_var(const char *pszParmName, const char *fmt, ...) PRINTF_ATTRIBUTE(2, 3);
+static BOOL do_parameter_var(struct loadparm_context *ctx, const char *pszParmName, const char *fmt, ...) PRINTF_ATTRIBUTE(3, 4);
 
-static BOOL do_parameter_var(const char *pszParmName, const char *fmt, ...)
+static BOOL do_parameter_var(struct loadparm_context *ctx, const char *pszParmName, const char *fmt, ...)
 {
 	char *s;
 	BOOL ret;
@@ -1956,7 +2001,7 @@
 	va_start(ap, fmt);	
 	s = talloc_vasprintf(NULL, fmt, ap);
 	va_end(ap);
-	ret = do_parameter(pszParmName, s, NULL);
+	ret = do_parameter(ctx, pszParmName, s);
 	talloc_free(s);
 	return ret;
 }
@@ -1967,7 +2012,8 @@
   parsing code. It sets the parameter then marks the parameter as unable to be modified
   by smb.conf processing
 */
-BOOL lp_set_cmdline(const char *pszParmName, const char *pszParmValue)
+BOOL lp_set_cmdline(struct loadparm_context *ctx, 
+					const char *pszParmName, const char *pszParmValue)
 {
 	int parmnum = map_parameter(pszParmName);
 	int i;
@@ -1977,7 +2023,9 @@
 
 	if (parmnum < 0 && strchr(pszParmName, ':')) {
 		/* set a parametric option */
-		return lp_do_parameter_parametric(-1, pszParmName, pszParmValue, FLAG_CMDLINE);
+		return lp_do_parameter_parametric(ctx, 
+										  -1, pszParmName, pszParmValue, 
+										  FLAG_CMDLINE);
 	}
 
 	if (parmnum < 0) {
@@ -1988,7 +2036,7 @@
 	/* reset the CMDLINE flag in case this has been called before */
 	parm_table[parmnum].flags &= ~FLAG_CMDLINE;
 
-	if (!lp_do_parameter(-2, pszParmName, pszParmValue)) {
+	if (!lp_do_parameter(ctx, -2, pszParmName, pszParmValue)) {
 		return False;
 	}
 
@@ -2008,7 +2056,7 @@
 /*
   set a option from the commandline in 'a=b' format. Use to support --option
 */
-BOOL lp_set_option(const char *option)
+BOOL lp_set_option(struct loadparm_context *ctx, const char *option)
 {
 	char *p, *s;
 	BOOL ret;
@@ -2026,7 +2074,7 @@
 
 	*p = 0;
 
-	ret = lp_set_cmdline(s, p+1);
+	ret = lp_set_cmdline(ctx, s, p+1);
 	free(s);
 	return ret;
 }
@@ -2124,12 +2172,13 @@
  Returns True on success, False on failure. 
 ***************************************************************************/
 
-static BOOL do_section(const char *pszSectionName, void *userdata)
+static BOOL parse_section(const char *pszSectionName, void *userdata)
 {
 	BOOL bRetval;
+	struct loadparm_context *ctx = userdata;
 	BOOL isglobal = ((strwicmp(pszSectionName, GLOBAL_NAME) == 0) ||
 			 (strwicmp(pszSectionName, GLOBAL_NAME2) == 0));
-	bRetval = False;
+	bRetval = false;
 
 	/* if we've just struck a global section, note the fact. */
 	bInGlobalSection = isglobal;
@@ -2137,14 +2186,14 @@
 	/* check for multiple global sections */
 	if (bInGlobalSection) {
 		DEBUG(3, ("Processing section \"[%s]\"\n", pszSectionName));
-		return (True);
+		return true;
 	}
 
 	/* if we have a current service, tidy it up before moving on */
-	bRetval = True;
+	bRetval = true;
 
 	if (iServiceIndex >= 0)
-		bRetval = service_ok(iServiceIndex);
+		bRetval = service_ok(ctx, iServiceIndex);
 
 	/* if all is still well, move to the next record in the services array */
 	if (bRetval) {
@@ -2152,14 +2201,14 @@
 		/* issued by the post-processing of a previous section. */
 		DEBUG(2, ("Processing section \"[%s]\"\n", pszSectionName));
 
-		if ((iServiceIndex = add_a_service(&sDefault, pszSectionName))
+		if ((iServiceIndex = add_a_service(ctx, &sDefault, pszSectionName))
 		    < 0) {
 			DEBUG(0, ("Failed to add a new service\n"));
-			return (False);
+			return false;
 		}
 	}
 
-	return (bRetval);
+	return bRetval;
 }
 
 
@@ -2269,9 +2318,10 @@
         }
 }
 
-BOOL lp_dump_a_parameter(int snum, char *parm_name, FILE * f, BOOL isGlobal)
+BOOL lp_dump_a_parameter(struct loadparm_context *ctx, 
+						 int snum, char *parm_name, FILE * f, BOOL isGlobal)
 {
-	service * pService = ServicePtrs[snum];
+	service * pService = ctx->ServicePtrs[snum];
 	struct parm_struct *parm;
 	void *ptr;
 	
@@ -2297,7 +2347,8 @@
  Return NULL when out of parameters.
 ***************************************************************************/
 
-struct parm_struct *lp_next_parameter(int snum, int *i, int allparameters)
+struct parm_struct *lp_next_parameter(struct loadparm_context *ctx, 
+									  int snum, int *i, int allparameters)
 {
 	if (snum == -1) {
 		/* do the globals */
@@ -2317,7 +2368,7 @@
 			return &parm_table[(*i)++];
 		}
 	} else {
-		service *pService = ServicePtrs[snum];
+		service *pService = ctx->ServicePtrs[snum];
 
 		for (; parm_table[*i].label; (*i)++) {
 			if (parm_table[*i].class == P_SEPARATOR)
@@ -2355,9 +2406,9 @@
  Return TRUE if the passed service number is within range.
 ***************************************************************************/
 
-BOOL lp_snum_ok(int iService)
+BOOL lp_snum_ok(struct loadparm_context *ctx, int iService)
 {
-	return (LP_SNUM_OK(iService) && ServicePtrs[iService]->bAvailable);
+	return (LP_SNUM_OK(iService) && ctx->ServicePtrs[iService]->bAvailable);
 }
 
 /***************************************************************************
@@ -2382,16 +2433,18 @@
  Unload unused services.
 ***************************************************************************/
 
-void lp_killunused(struct smbsrv_connection *smb, BOOL (*snumused) (struct smbsrv_connection *, int))
+void lp_killunused(struct loadparm_context *ctx, 
+				   struct smbsrv_connection *smb, 
+				   BOOL (*snumused) (struct smbsrv_connection *, int))
 {
 	int i;
-	for (i = 0; i < iNumServices; i++) {
+	for (i = 0; i < global_params.iNumServices; i++) {
 		if (!VALID(i))
 			continue;
 
 		if (!snumused || !snumused(smb, i)) {
-			ServicePtrs[i]->valid = False;
-			free_service(ServicePtrs[i]);
+			ctx->ServicePtrs[i]->valid = false;
+			free_service(ctx->ServicePtrs[i]);
 		}
 	}
 }
@@ -2400,11 +2453,11 @@
  Unload a service.
 ***************************************************************************/
 
-void lp_killservice(int iServiceIn)
+void lp_killservice(struct loadparm_context *ctx, int iServiceIn)
 {
 	if (VALID(iServiceIn)) {
-		ServicePtrs[iServiceIn]->valid = False;
-		free_service(ServicePtrs[iServiceIn]);
+		ctx->ServicePtrs[iServiceIn]->valid = false;
+		free_service(ctx->ServicePtrs[iServiceIn]);
 	}
 }
 
@@ -2418,10 +2471,11 @@
 	pstring n2;
 	BOOL bRetval;
 	struct param_opt *data;
-
-	bRetval = False;
-
-	bInGlobalSection = True;
+	struct loadparm_context *ctx = &global_params;
+
+	bRetval = false;
+
+	bInGlobalSection = true;
 
 	if (Globals.param_opt != NULL) {
 		struct param_opt *next;
@@ -2445,77 +2499,79 @@
 
 	/* We get sections first, so have to start 'behind' to make up */
 	iServiceIndex = -1;
-	bRetval = pm_process(n2, do_section, do_parameter, NULL);
+	bRetval = pm_process(n2, parse_section, parse_parameter, ctx);
 
 	/* finish up the last section */
 	DEBUG(4, ("pm_process() returned %s\n", BOOLSTR(bRetval)));
 	if (bRetval)
 		if (iServiceIndex >= 0)
-			bRetval = service_ok(iServiceIndex);
+			bRetval = service_ok(ctx, iServiceIndex);
 
 	lp_add_auto_services(lp_auto_services());
 
-	lp_add_hidden("IPC$", "IPC");
-	lp_add_hidden("ADMIN$", "DISK");
+	lp_add_hidden(ctx, "IPC$", "IPC");
+	lp_add_hidden(ctx, "ADMIN$", "DISK");
 
-	bLoaded = True;
+	bLoaded = true;
 
 	if (!Globals.szWINSservers && Globals.bWINSsupport) {
-		lp_do_parameter(-1, "wins server", "127.0.0.1");
+		lp_do_parameter(ctx, -1, "wins server", "127.0.0.1");
 	}
 
 	init_iconv();
 
-	return (bRetval);
+	return bRetval;
 }
 
 /***************************************************************************
  Reset the max number of services.
 ***************************************************************************/
 
-void lp_resetnumservices(void)
+void lp_resetnumservices(struct loadparm_context *ctx)
 {
-	iNumServices = 0;
+	ctx->iNumServices = 0;
 }
 
 /***************************************************************************
  Return the max number of services.
 ***************************************************************************/
 
-int lp_numservices(void)
+int lp_numservices(struct loadparm_context *ctx)
 {
-	return (iNumServices);
+	return (ctx->iNumServices);
 }
 
 /***************************************************************************
 Display the contents of the services array in human-readable form.
 ***************************************************************************/
 
-void lp_dump(FILE *f, BOOL show_defaults, int maxtoprint)
+void lp_dump(struct loadparm_context *ctx, 
+			 FILE *f, BOOL show_defaults, int maxtoprint)
 {
 	int iService;
 
 	if (show_defaults)
-		defaults_saved = False;
+		defaults_saved = false;
 
 	dump_globals(f, show_defaults);
 
 	dump_a_service(&sDefault, f);
 
 	for (iService = 0; iService < maxtoprint; iService++)
-		lp_dump_one(f, show_defaults, iService);
+		lp_dump_one(ctx, f, show_defaults, iService);
 }
 
 /***************************************************************************
 Display the contents of one service in human-readable form.
 ***************************************************************************/
 
-void lp_dump_one(FILE * f, BOOL show_defaults, int snum)
+void lp_dump_one(struct loadparm_context *ctx, 
+				 FILE * f, BOOL show_defaults, int snum)
 {
 	if (VALID(snum)) {
-		if (ServicePtrs[snum]->szService[0] == '\0')
+		if (ctx->ServicePtrs[snum]->szService[0] == '\0')
 			return;
-		dump_a_service(ServicePtrs[snum], f);
+		dump_a_service(ctx->ServicePtrs[snum], f);
 	}
 }
 
@@ -2526,19 +2582,19 @@
 does not copy the found service.
 ***************************************************************************/
 
-int lp_servicenumber(const char *pszServiceName)
+int lp_servicenumber(struct loadparm_context *ctx, const char *pszServiceName)
 {
 	int iService;
         fstring serviceName;
  
  
-	for (iService = iNumServices - 1; iService >= 0; iService--) {
-		if (VALID(iService) && ServicePtrs[iService]->szService) {
+	for (iService = ctx->iNumServices - 1; iService >= 0; iService--) {
+		if (VALID(iService) && ctx->ServicePtrs[iService]->szService) {
 			/*
 			 * The substitution here is used to support %U is
 			 * service names
 			 */
-			fstrcpy(serviceName, ServicePtrs[iService]->szService);
+			fstrcpy(serviceName, ctx->ServicePtrs[iService]->szService);
 			standard_sub_basic(serviceName,sizeof(serviceName));
 			if (strequal(serviceName, pszServiceName))
 				break;
@@ -2551,13 +2607,14 @@
 	return (iService);
 }
 
-int lp_find_valid_service(const char *pszServiceName)
+int lp_find_valid_service(struct loadparm_context *ctx, 
+						  const char *pszServiceName)
 {
 	int iService;
 
-	iService = lp_servicenumber(pszServiceName);
+	iService = lp_servicenumber(ctx, pszServiceName);
 
-	if (iService >= 0 && !lp_snum_ok(iService)) {
+	if (iService >= 0 && !lp_snum_ok(ctx, iService)) {
 		DEBUG(0,("lp_find_valid_service: Invalid snum %d for '%s'\n",iService, pszServiceName));
 		iService = -1;
 	}
@@ -2594,23 +2651,24 @@
  Remove a service.
 ********************************************************************/
 
-void lp_remove_service(int snum)
+void lp_remove_service(struct loadparm_context *ctx, int snum)
 {
-	ServicePtrs[snum]->valid = False;
+	ctx->ServicePtrs[snum]->valid = false;
 }
 
 /*******************************************************************
  Copy a service.
 ********************************************************************/
 
-void lp_copy_service(int snum, const char *new_name)
+void lp_copy_service(struct loadparm_context *ctx, 
+					 int snum, const char *new_name)
 {
 	const char *oldname = lp_servicename(snum);
-	do_section(new_name, NULL);
+	parse_section(new_name, ctx);
 	if (snum >= 0) {
-		snum = lp_servicenumber(new_name);
+		snum = lp_servicenumber(ctx, new_name);
 		if (snum >= 0)
-			lp_do_parameter(snum, "copy", oldname);
+			lp_do_parameter(ctx, snum, "copy", oldname);
 	}
 }
 
@@ -2628,9 +2686,9 @@
  Return the max print jobs per queue.
 ********************************************************************/
 
-int lp_maxprintjobs(int snum)
+int lp_maxprintjobs(struct loadparm_context *ctx, int snum)
 {
-	int maxjobs = LP_SNUM_OK(snum) ? ServicePtrs[snum]->iMaxPrintJobs : sDefault.iMaxPrintJobs;
+	int maxjobs = LP_SNUM_OK(snum) ? ctx->ServicePtrs[snum]->iMaxPrintJobs : sDefault.iMaxPrintJobs;
 	if (maxjobs <= 0 || maxjobs >= PRINT_MAX_JOBID)
 		maxjobs = PRINT_MAX_JOBID - 1;
 

=== modified file source/param/loadparm.h
--- source/param/loadparm.h
+++ source/param/loadparm.h
@@ -28,6 +28,12 @@
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#ifndef __LOADPARM_H__
+#define __LOADPARM_H__
+
+struct loadparm_context;
+extern struct loadparm_context global_params;
+
 /* the following are used by loadparm for option lists */
 typedef enum {
 	P_BOOL,P_INTEGER,P_BYTES,P_LIST,P_STRING,P_USTRING,P_ENUM,P_SEP
@@ -47,7 +53,7 @@
 	parm_type type;
 	parm_class class;
 	void *ptr;
-	BOOL (*special)(const char *, char **);
+	BOOL (*special)(struct loadparm_context *, const char *, char **);
 	const struct enum_list *enum_list;
 	unsigned int flags;
 	union {
@@ -79,3 +85,4 @@
 #define HOMES_NAME "homes"
 #endif
 
+#endif /* __LOADPARM_H__ */

=== modified file source/param/param.h
--- source/param/param.h
+++ source/param/param.h
@@ -43,6 +43,7 @@
 
 #define Auto (2)
 
+#include "param/loadparm.h"
 #include "param/proto.h"
 
 #endif /* _PARAM_H */

=== modified file source/param/share_classic.c
--- source/param/share_classic.c
+++ source/param/share_classic.c
@@ -154,7 +154,7 @@
 	}
 
 	if (strcmp(opt_name, SHARE_AVAILABLE) == 0) {
-		return lp_snum_ok(s->snum);
+		return lp_snum_ok(&global_params, s->snum);
 	}
 
 	if (strcmp(opt_name, SHARE_BROWSEABLE) == 0) {
@@ -240,7 +240,7 @@
 	int num_services;
 	const char **n;
        
-	num_services = lp_numservices();
+	num_services = lp_numservices(&global_params);
 
 	n = talloc_array(mem_ctx, const char *, num_services);
 	if (!n) {
@@ -273,7 +273,7 @@
 	struct sclassic_snum *scnum;
 
 	snum = -1;
-	for (i = 0; i < lp_numservices(); i++) {
+	for (i = 0; i < lp_numservices(&global_params); i++) {
 		if (strcasecmp_m(name, lp_servicename(i)) == 0) {
 			snum = i;
 			break;

=== modified file source/scripting/ejs/smbcalls_config.c
--- source/scripting/ejs/smbcalls_config.c
+++ source/scripting/ejs/smbcalls_config.c
@@ -36,7 +36,7 @@
 	const char **list = NULL;
 	if (argc != 0) return -1;
 	
-	for (i=0;i<lp_numservices();i++) {
+	for (i=0;i<lp_numservices(&global_params);i++) {
 		list = str_list_add(list, lp_servicename(i));
 	}
 	talloc_steal(mprMemCtx(), list);
@@ -88,7 +88,7 @@
 
 	if (argc == 2) {
 		/* its a share parameter */
-		int snum = lp_servicenumber(argv[0]);
+		int snum = lp_servicenumber(&global_params, argv[0]);
 		if (snum == -1) {
 			return -1;
 		}
@@ -100,7 +100,7 @@
 			const char *option = strchr(argv[1], ':') + 1;
 			const char *value;
 			if (type == NULL || option == NULL) return -1;
-			value = lp_get_parametric(snum, type, option);
+			value = lp_get_parametric(&global_params, snum, type, option);
 			if (value == NULL) return -1;
 			mpr_ReturnString(eid, value);
 			return 0;
@@ -110,7 +110,7 @@
 		if (parm == NULL || parm->class == P_GLOBAL) {
 			return -1;
 		}
-		parm_ptr = lp_parm_ptr(snum, parm);
+		parm_ptr = lp_parm_ptr(&global_params, snum, parm);
 	} else if (strchr(argv[0], ':')) {
 		/* its a global parametric option */
 		const char *type = talloc_strndup(mprMemCtx(), 
@@ -118,7 +118,7 @@
 		const char *option = strchr(argv[0], ':') + 1;
 		const char *value;
 		if (type == NULL || option == NULL) return -1;
-		value = lp_get_parametric(-1, type, option);
+		value = lp_get_parametric(&global_params, -1, type, option);
 		if (value == NULL) return -1;
 		mpr_ReturnString(eid, value);
 		return 0;
@@ -126,7 +126,7 @@
 		/* its a global parameter */
 		parm = lp_parm_struct(argv[0]);
 		if (parm == NULL) return -1;
-		parm_ptr = lp_parm_ptr(-1, parm);
+		parm_ptr = lp_parm_ptr(&global_params, -1, parm);
 	}
 
 	if (parm == NULL || parm_ptr == NULL) {
@@ -178,7 +178,8 @@
 		return -1;
 	}
 
-	mpr_Return(eid, mprCreateBoolVar(lp_set_cmdline(argv[0], argv[1])));
+	mpr_Return(eid, mprCreateBoolVar(lp_set_cmdline(&global_params, 
+													argv[0], argv[1])));
 	return 0;
 }
 

=== modified file source/scripting/ejs/smbscript.c
--- source/scripting/ejs/smbscript.c
+++ source/scripting/ejs/smbscript.c
@@ -53,7 +53,7 @@
 	fault_setup(argv[0]);
 
 	if (getenv("SMB_CONF_PATH")) {
-		lp_set_cmdline("config file", getenv("SMB_CONF_PATH"));
+		lp_set_cmdline(&global_params, "config file", getenv("SMB_CONF_PATH"));
 	}
 
 	ldb_global_init();

=== modified file source/torture/basic/base.c
--- source/torture/basic/base.c
+++ source/torture/basic/base.c
@@ -1445,7 +1445,7 @@
 
 	nt_status_support = lp_nt_status_support();
 
-	if (!lp_set_cmdline("nt status support", "yes")) {
+	if (!lp_set_cmdline(&global_params, "nt status support", "yes")) {
 		torture_comment(tctx, "Could not set 'nt status support = yes'\n");
 		goto fail;
 	}
@@ -1454,7 +1454,7 @@
 		goto fail;
 	}
 
-	if (!lp_set_cmdline("nt status support", "no")) {
+	if (!lp_set_cmdline(&global_params, "nt status support", "no")) {
 		torture_comment(tctx, "Could not set 'nt status support = yes'\n");
 		goto fail;
 	}
@@ -1463,7 +1463,7 @@
 		goto fail;
 	}
 
-	if (!lp_set_cmdline("nt status support",
+	if (!lp_set_cmdline(&global_params, "nt status support",
 			    nt_status_support ? "yes":"no")) {
 		torture_comment(tctx, "Could not reset 'nt status support = yes'");
 		goto fail;

=== modified file source/torture/local/irpc.c
--- source/torture/local/irpc.c
+++ source/torture/local/irpc.c
@@ -215,7 +215,7 @@
 
 	*_data = data = talloc(tctx, struct irpc_test_data);
 
-	lp_set_cmdline("lock dir", "lockdir.tmp");
+	lp_set_cmdline(&global_params, "lock dir", "lockdir.tmp");
 
 	data->ev = event_context_init(tctx);
 	torture_assert(tctx, data->msg_ctx1 = 

=== modified file source/torture/local/messaging.c
--- source/torture/local/messaging.c
+++ source/torture/local/messaging.c
@@ -68,7 +68,7 @@
 	uint32_t msg_ping, msg_exit;
 	TALLOC_CTX *mem_ctx = tctx;
 
-	lp_set_cmdline("pid directory", "piddir.tmp");
+	lp_set_cmdline(&global_params, "pid directory", "piddir.tmp");
 
 	ev = event_context_init(mem_ctx);
 

=== modified file source/torture/locktest.c
--- source/torture/locktest.c
+++ source/torture/locktest.c
@@ -614,10 +614,10 @@
 			exact_error_codes = True;
 			break;
 		case 'l':
-			lp_set_cmdline("torture:unclist", optarg);
+			lp_set_cmdline(&global_params, "torture:unclist", optarg);
 			break;
 		case 'W':
-			lp_set_cmdline("workgroup", optarg);
+			lp_set_cmdline(&global_params, "workgroup", optarg);
 			break;
 		case 'h':
 			usage();

=== modified file source/torture/masktest.c
--- source/torture/masktest.c
+++ source/torture/masktest.c
@@ -285,7 +285,7 @@
 
 	setup_logging("masktest", DEBUG_STDOUT);
 
-	lp_set_cmdline("log level", "0");
+	lp_set_cmdline(&global_params, "log level", "0");
 
 	if (argc < 2 || argv[1][0] == '-') {
 		usage();
@@ -325,7 +325,7 @@
 			verbose++;
 			break;
 		case 'M':
-			lp_set_cmdline("max protocol", optarg);
+			lp_set_cmdline(&global_params, "max protocol", optarg);
 			break;
 		case 'U':
 			cli_credentials_parse_string(credentials, optarg, CRED_SPECIFIED);

=== modified file source/torture/raw/context.c
--- source/torture/raw/context.c
+++ source/torture/raw/context.c
@@ -906,7 +906,7 @@
 	BOOL ret = True;
 	if (lp_use_spnego()) {
 		ret &= torture_raw_context_int();
-		lp_set_cmdline("use spnego", "False");
+		lp_set_cmdline(&global_params, "use spnego", "False");
 	}
 
 	ret &= torture_raw_context_int();

=== modified file source/torture/raw/samba3misc.c
--- source/torture/raw/samba3misc.c
+++ source/torture/raw/samba3misc.c
@@ -237,7 +237,7 @@
 
 	nt_status_support = lp_nt_status_support();
 
-	if (!lp_set_cmdline("nt status support", "yes")) {
+	if (!lp_set_cmdline(&global_params, "nt status support", "yes")) {
 		printf("Could not set 'nt status support = yes'\n");
 		goto fail;
 	}
@@ -246,7 +246,7 @@
 		goto fail;
 	}
 
-	if (!lp_set_cmdline("nt status support", "no")) {
+	if (!lp_set_cmdline(&global_params, "nt status support", "no")) {
 		printf("Could not set 'nt status support = yes'\n");
 		goto fail;
 	}
@@ -255,7 +255,7 @@
 		goto fail;
 	}
 
-	if (!lp_set_cmdline("nt status support",
+	if (!lp_set_cmdline(&global_params, "nt status support",
 			    nt_status_support ? "yes":"no")) {
 		printf("Could not reset 'nt status support = yes'");
 		goto fail;

=== modified file source/torture/rpc/mgmt.c
--- source/torture/rpc/mgmt.c
+++ source/torture/rpc/mgmt.c
@@ -232,7 +232,7 @@
 			continue;
 		}
 
-		lp_set_cmdline("torture:binding", dcerpc_binding_string(loop_ctx, b));
+		lp_set_cmdline(&global_params, "torture:binding", dcerpc_binding_string(loop_ctx, b));
 
 		status = torture_rpc_connection(loop_ctx, &p, &dcerpc_table_mgmt);
 		if (NT_STATUS_EQUAL(status, NT_STATUS_OBJECT_NAME_NOT_FOUND)) {

=== modified file source/torture/rpc/scanner.c
--- source/torture/rpc/scanner.c
+++ source/torture/rpc/scanner.c
@@ -141,7 +141,7 @@
 			b->endpoint = talloc_strdup(b, l->table->name);
 		}
 
-		lp_set_cmdline("torture:binding", dcerpc_binding_string(mem_ctx, b));
+		lp_set_cmdline(&global_params, "torture:binding", dcerpc_binding_string(mem_ctx, b));
 
 		status = torture_rpc_connection(loop_ctx, &p, &dcerpc_table_mgmt);
 		if (!NT_STATUS_IS_OK(status)) {

=== modified file source/torture/smbtorture.c
--- source/torture/smbtorture.c
+++ source/torture/smbtorture.c
@@ -131,33 +131,33 @@
 	/* retrievieng the userdn */
 	p = strchr_m(dns, '#');
 	if (!p) {
-		lp_set_cmdline("torture:ldap_userdn", "");
-		lp_set_cmdline("torture:ldap_basedn", "");
-		lp_set_cmdline("torture:ldap_secret", "");
+		lp_set_cmdline(&global_params, "torture:ldap_userdn", "");
+		lp_set_cmdline(&global_params, "torture:ldap_basedn", "");
+		lp_set_cmdline(&global_params, "torture:ldap_secret", "");
 		return;
 	}
 	userdn = strndup(dns, p - dns);
-	lp_set_cmdline("torture:ldap_userdn", userdn);
+	lp_set_cmdline(&global_params, "torture:ldap_userdn", userdn);
 
 	/* retrieve the basedn */
 	d = p + 1;
 	p = strchr_m(d, '#');
 	if (!p) {
-		lp_set_cmdline("torture:ldap_basedn", "");
-		lp_set_cmdline("torture:ldap_secret", "");
+		lp_set_cmdline(&global_params, "torture:ldap_basedn", "");
+		lp_set_cmdline(&global_params, "torture:ldap_secret", "");
 		return;
 	}
 	basedn = strndup(d, p - d);
-	lp_set_cmdline("torture:ldap_basedn", basedn);
+	lp_set_cmdline(&global_params, "torture:ldap_basedn", basedn);
 
 	/* retrieve the secret */
 	p = p + 1;
 	if (!p) {
-		lp_set_cmdline("torture:ldap_secret", "");
+		lp_set_cmdline(&global_params, "torture:ldap_secret", "");
 		return;
 	}
 	secret = strdup(p);
-	lp_set_cmdline("torture:ldap_secret", secret);
+	lp_set_cmdline(&global_params, "torture:ldap_secret", secret);
 
 	printf ("%s - %s - %s\n", userdn, basedn, secret);
 
@@ -479,7 +479,7 @@
 				fprintf(stderr, "Usage: set <variable> <value>\n");
 			} else {
 				char *name = talloc_asprintf(NULL, "torture:%s", argv[1]);
-				lp_set_cmdline(name, argv[2]);
+				lp_set_cmdline(&global_params, name, argv[2]);
 				talloc_free(name);
 			}
 		} else if (!strcmp(argv[0], "help")) {
@@ -565,39 +565,39 @@
 	while((opt = poptGetNextOpt(pc)) != -1) {
 		switch (opt) {
 		case OPT_LOADFILE:
-			lp_set_cmdline("torture:loadfile", poptGetOptArg(pc));
+			lp_set_cmdline(&global_params, "torture:loadfile", poptGetOptArg(pc));
 			break;
 		case OPT_UNCLIST:
-			lp_set_cmdline("torture:unclist", poptGetOptArg(pc));
+			lp_set_cmdline(&global_params, "torture:unclist", poptGetOptArg(pc));
 			break;
 		case OPT_TIMELIMIT:
-			lp_set_cmdline("torture:timelimit", poptGetOptArg(pc));
+			lp_set_cmdline(&global_params, "torture:timelimit", poptGetOptArg(pc));
 			break;
 		case OPT_NUMPROGS:
-			lp_set_cmdline("torture:nprocs", poptGetOptArg(pc));
+			lp_set_cmdline(&global_params, "torture:nprocs", poptGetOptArg(pc));
 			break;
 		case OPT_BASEDIR:
-			lp_set_cmdline("torture:basedir", poptGetOptArg(pc));
+			lp_set_cmdline(&global_params, "torture:basedir", poptGetOptArg(pc));
 			break;
 		case OPT_DNS:
 			parse_dns(poptGetOptArg(pc));
 			break;
 		case OPT_DANGEROUS:
-			lp_set_cmdline("torture:dangerous", "Yes");
+			lp_set_cmdline(&global_params, "torture:dangerous", "Yes");
 			break;
 		case OPT_ASYNC:
-			lp_set_cmdline("torture:async", "Yes");
+			lp_set_cmdline(&global_params, "torture:async", "Yes");
 			break;
 		case OPT_SMB_PORTS:
-			lp_set_cmdline("smb ports", poptGetOptArg(pc));
+			lp_set_cmdline(&global_params, "smb ports", poptGetOptArg(pc));
 			break;
 		}
 	}
 
 	if (strcmp(target, "samba3") == 0) {
-		lp_set_cmdline("torture:samba3", "true");
+		lp_set_cmdline(&global_params, "torture:samba3", "true");
 	} else if (strcmp(target, "samba4") == 0) {
-		lp_set_cmdline("torture:samba4", "true");
+		lp_set_cmdline(&global_params, "torture:samba4", "true");
 	}
 
 	if (max_runtime) {
@@ -642,9 +642,9 @@
 	/* see if its a RPC transport specifier */
 	status = dcerpc_parse_binding(talloc_autofree_context(), argv_new[1], &binding_struct);
 	if (NT_STATUS_IS_OK(status)) {
-		lp_set_cmdline("torture:host", binding_struct->host);
-		lp_set_cmdline("torture:share", "IPC$");
-		lp_set_cmdline("torture:binding", argv_new[1]);
+		lp_set_cmdline(&global_params, "torture:host", binding_struct->host);
+		lp_set_cmdline(&global_params, "torture:share", "IPC$");
+		lp_set_cmdline(&global_params, "torture:binding", argv_new[1]);
 	} else {
 		char *binding = NULL;
 		char *host = NULL, *share = NULL;
@@ -654,10 +654,10 @@
 			usage(pc);
 		}
 
-		lp_set_cmdline("torture:host", host);
-		lp_set_cmdline("torture:share", share);
+		lp_set_cmdline(&global_params, "torture:host", host);
+		lp_set_cmdline(&global_params, "torture:share", share);
 		asprintf(&binding, "ncacn_np:%s", host);
-		lp_set_cmdline("torture:binding", binding);
+		lp_set_cmdline(&global_params, "torture:binding", binding);
 	}
 
 	if (!strcmp(ui_ops_name, "simple")) {

=== modified file source/torture/util_smb.c
--- source/torture/util_smb.c
+++ source/torture/util_smb.c
@@ -646,7 +646,7 @@
 			srandom(((int)mypid) ^ ((int)time(NULL)));
 
 			asprintf(&myname, "CLIENT%d", i);
-			lp_set_cmdline("netbios name", myname);
+			lp_set_cmdline(&global_params, "netbios name", myname);
 			free(myname);
 
 

=== modified file source/utils/testparm.c
--- source/utils/testparm.c
+++ source/utils/testparm.c
@@ -137,7 +137,7 @@
 */
 	
 	/* We need this to force the output */
-	lp_set_cmdline("log level", "2");
+	lp_set_cmdline(&global_params, "log level", "2");
 
 	fprintf(stderr,"Load smb config files from %s\n",lp_configfile());
 
@@ -150,8 +150,8 @@
 
 	ret = do_global_checks();
 
-	for (s=0;s<lp_numservices();s++) {
-		if (lp_snum_ok(s))
+	for (s=0;s<lp_numservices(&global_params);s++) {
+		if (lp_snum_ok(&global_params, s))
 			if (strlen(lp_servicename(s)) > 12) {
 				fprintf(stderr, "WARNING: You have some share names that are longer than 12 characters.\n" );
 				fprintf(stderr, "These may not be accessible to some older clients.\n" );
@@ -160,8 +160,8 @@
 			}
 	}
 
-	for (s=0;s<lp_numservices();s++) {
-		if (lp_snum_ok(s)) {
+	for (s=0;s<lp_numservices(&global_params);s++) {
+		if (lp_snum_ok(&global_params, s)) {
 			const char **deny_list = lp_hostsdeny(s);
 			const char **allow_list = lp_hostsallow(s);
 			int i;
@@ -202,30 +202,30 @@
 				section_name = GLOBAL_NAME;
 				isGlobal = True;
 			} else if ((isGlobal=!strwicmp(section_name, GLOBAL_NAME)) == 0 &&
-				 (s=lp_servicenumber(section_name)) == -1) {
+				 (s=lp_servicenumber(&global_params, section_name)) == -1) {
 					fprintf(stderr,"Unknown section %s\n",
 						section_name);
 					return(1);
 			}
 			if (!parameter_name) {
 				if (isGlobal == True) {
-					lp_dump(stdout, show_defaults, 0);
+					lp_dump(&global_params, stdout, show_defaults, 0);
 				} else {
-					lp_dump_one(stdout, show_defaults, s);
+					lp_dump_one(&global_params, stdout, show_defaults, s);
 				}
 			} else {
-				ret = !lp_dump_a_parameter(s, parameter_name, stdout, isGlobal);
+				ret = !lp_dump_a_parameter(&global_params, s, parameter_name, stdout, isGlobal);
 			}
 		} else {
-			lp_dump(stdout, show_defaults, lp_numservices());
+			lp_dump(&global_params, stdout, show_defaults, lp_numservices(&global_params));
 		}
 		return(ret);
 	}
 
 	if(cname && caddr){
 		/* this is totally ugly, a real `quick' hack */
-		for (s=0;s<lp_numservices();s++) {
-			if (lp_snum_ok(s)) {
+		for (s=0;s<lp_numservices(&global_params);s++) {
+			if (lp_snum_ok(&global_params, s)) {
 				if (allow_access(NULL, lp_hostsdeny(-1), lp_hostsallow(-1), cname, caddr)
 				    && allow_access(NULL, lp_hostsdeny(s), lp_hostsallow(s), cname, caddr)) {
 					fprintf(stderr,"Allow connection from %s (%s) to %s\n",

=== modified directory  // last-changed:jelmer@samba.org-20070509011150-9opq848
... pjvql0065
# revision id: jelmer@samba.org-20070509011150-9opq848pjvql0065
# sha1: 4637fefc3d334de54561cf421ec864e2ac23620f
# inventory sha1: 790908438dcdbe8af74681ee6ccd7737555b8218
# parent ids:
#   svn-v2:22758@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0
# base id: svn-v2:22758@0c0555d6-39d7-0310-84fc-f1cc0bd64818-branches%2fSAMBA_4_0
# properties:
#   branch-nick: SAMBA_4_0


--------------040101030009020405090304
Content-Type: application/pgp-signature;
 name="loadparm-ctx.bundle.diff.sig"
Content-Transfer-Encoding: base64
Content-Disposition: inline;
 filename="loadparm-ctx.bundle.diff.sig"

iQCUAwUARkGv0Ay0JeEGD2blAQKmQAP4w8DpgUYCe/AqUL0R37t6x236dkyP08/BqsvY67Xe
JwmquGOH6qXrxs1iggDfkwfMAR9cZCySBp5d9yxL+TanfAvoh439zbNqEz+YOYP7FjBxVPCX
oL8D25v5TZ6dXLAYzFb6XEsLcyWF1T0XiVqhsITDauHXvt/Oin7+z0VR3w==
--------------040101030009020405090304--

