From perl6-all-return-80939-ktwarwic=speedy.uwaterloo.ca@perl.org  Fri Apr 27 17:45:24 2007
Return-Path: <perl6-all-return-80939-ktwarwic=speedy.uwaterloo.ca@perl.org>
Received: from lists.develooper.com (x6.develooper.com [63.251.223.186])
	by speedy.uwaterloo.ca (8.12.8/8.12.5) with SMTP id l3RLj96w031444
	for <ktwarwic@speedy.uwaterloo.ca>; Fri, 27 Apr 2007 17:45:10 -0400
Received: (qmail 17269 invoked by uid 514); 27 Apr 2007 21:45:08 -0000
Mailing-List: contact perl6-all-help@perl.org; run by ezmlm
Precedence: bulk
List-Post: <mailto:perl6-all@perl.org>
List-Help: <mailto:perl6-all-help@perl.org>
List-Unsubscribe: <mailto:perl6-all-unsubscribe@perl.org>
List-Subscribe: <mailto:perl6-all-subscribe@perl.org>
List-Id: <perl6-all.perl.org>
Delivered-To: mailing list perl6-all@perl.org
Received: (qmail 17264 invoked from network); 27 Apr 2007 21:45:08 -0000
Delivered-To: perl6-all-poster@perl.org
X-Spam-Status: No, hits=-2.6 required=8.0
	tests=BAYES_00,DK_POLICY_SIGNSOME
X-Spam-Check-By: la.mx.develooper.com
Received-SPF: pass (x1.develooper.com: local policy)
X-Mailing-List: contact perl6-internals-help@perl.org; run by ezmlm
X-Mailing-List-Name: perl6-internals
List-Id: <perl6-internals.perl.org>
Delivered-To: mailing list perl6-internals@perl.org
Delivered-To: perl6-internals@perl.org
Received-SPF: pass (x1.develooper.com: local policy)
From: James Keenan (via RT) <parrotbug-followup@parrotcode.org>
X-RT-NewTicket: yes
To: bugs-bitbucket@netlabs.develooper.com
Resent-To: perl6-internals@perl.org
Mail-Followup-To: perl6-internals@perl.org
Reply-To: perl6-internals@perl.org
Date: Fri, 27 Apr 2007 14:43:56 -0700
Subject: [perl #42777] [PATCH] Configure.pl and underlying packages:  Eliminate temporary hack 
In-Reply-To: <D3E5E21E-98AA-4CCA-B602-3E9C75809BDF@verizon.net>
References: <RT-Ticket-42777@perl.org> <D3E5E21E-98AA-4CCA-B602-3E9C75809BDF@verizon.net>
Message-ID: <rt-3.6.HEAD-30201-1177710236-1809.42777-72-0@perl.org>
X-RT-Loop-Prevention: perl
RT-Ticket: perl #42777
Managed-by: RT 3.6.HEAD (http://www.bestpractical.com/rt/)
RT-Originator: jkeen@verizon.net
MIME-Version: 1.0
X-RT-Original-Encoding: utf-8
Content-type: multipart/mixed; boundary="----------=_1177710237-30201-219"
Resent-Message-Id: <20070427214358.26E512AFD8@x3.develooper.com>
Resent-Date: Fri, 27 Apr 2007 14:43:58 -0700 (PDT)
Resent-From: rt-jkeen=verizon.net@netlabs.develooper.com
X-Virus-Checked: Checked
X-Virus-Checked: Checked
X-Old-Spam-Check-By: la.mx.develooper.com
X-Old-Spam-Status: No, hits=-4.4 required=8.0
	tests=ALL_TRUSTED,BAYES_00,DK_POLICY_SIGNSOME
Status: O
Content-Length: 78335
Lines: 2685

------------=_1177710237-30201-219
Content-Type: text/plain; charset="utf-8"
Content-Transfer-Encoding: 8bit

# New Ticket Created by  James Keenan 
# Please include the string:  [perl #42777]
# in the subject line of all future correspondence about this issue. 
# <URL: http://rt.perl.org/rt3/Ticket/Display.html?id=42777 >


This is the fourth in a series of patches which refactor code in  
Configure.pl and the Parrot::Configure::* packages used in the  
configuration process.

Part of this patch was previously submitted as a patch to http:// 
rt.perl.org/rt3/Ticket/Display.html?id=41201 "[TODO] Remove temporary  
conf hack in Configure.pl".  Because this patch incorporates and  
supersedes that patch, I will be closing RT 41201 in favor of this  
ticket.

The most significant difference between this patch and the current  
configuration system is that, in order to eliminate the "temporary  
hack" described by Paul Cochrane in RT 41201, the Parrot::Configure  
object had to become a singleton.  Besides changes in lib/Parrot/ 
Configure.pm, this required changes in Configure.pl, lib/Parrot/ 
Configure/Step.pm and config/init/defaults.pm.  It also required the  
deletion of the current t/configure/configure.t because that file's  
tests were structured on the presumption of a non-singleton object.

Fourteen additional test files have been created as part of this  
patch.  The purpose of these tests is to (a) replace testing  
functionality lost when t/configure/configure.t was eliminated; and  
(b) to increase the test coverage, particularly in lib/Parrot/ 
Configure.pm.  A file with coverage analysis will be supplied in a  
separate posting to this thread.  To provide data for some of these  
tests, several dummy .pm packages were created in new directory t/ 
configure/testlib/.

As I performed coverage analysis I realized that certain code in  
Parrot::Configure::Data was misformulated -- specifically,  
Parrot::Configure::Data::slurp().  I have corrected this code and  
provided a new test file in a new test directory, t/postconfigure/01- 
data_slurp.t to test the correction.  I added t/postconfigure/ to the  
list of directories in t/harness tested by default during 'make test'.

Since the end result of the configuration process is % 
Parrot::Config::Generated::PConfig, I compared that hash in both HEAD  
and in my local branch.  The configuration was the same, which should  
mean that the net effect of this patch on the configuration process  
is zero -- which is a good thing.

There are plenty of areas where the test coverage can still be  
improved, but I think what I've got so far is sufficient for  
application to trunk.

As with the previous patches in this series, I'd like to request  
feedback on the patches over the next three days, after which I will  
apply them to trunk.

Thank you very much.

kid51


------------=_1177710237-30201-219
Content-Type: text/plain;
 charset="ascii";
 name="configure.singleton.patch.txt"
Content-Disposition: inline; filename="configure.singleton.patch.txt"
Content-Transfer-Encoding: 7bit
RT-Attachment: 42777/253857/112005

Index: Configure.pl
===================================================================
--- Configure.pl	(revision 18347)
+++ Configure.pl	(working copy)
@@ -257,6 +257,8 @@
 use 5.006_001;
 use strict;
 use warnings;
+use Data::Dumper;
+$Data::Dumper::Indent = 1;
 use lib 'lib';
 
 use Parrot::BuildUtil;
@@ -268,11 +270,9 @@
 );
 use Parrot::Configure::Step::List qw( get_steps_list );
 
-# These globals are accessed in config/init/defaults.pm
-our $parrot_version = Parrot::BuildUtil::parrot_version();
-our @parrot_version = Parrot::BuildUtil::parrot_version();
+my $parrot_version = Parrot::BuildUtil::parrot_version();
 
-$| = 1;
+$| = 1; # $OUTPUT_AUTOFLUSH = 1;
 
 # Install Option text was taken from:
 #
@@ -284,14 +284,12 @@
 # warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
 # from Parrot::Configure::Options
-my $args = process_options(
-    {
-        argv           => [@ARGV],
-        script         => $0,
-        parrot_version => $parrot_version,
-        svnid          => '$Id$',
-    }
-);
+my $args = process_options( {
+    argv            => [ @ARGV ],
+    script          => $0,
+    parrot_version  => $parrot_version,
+    svnid           => '$Id$',
+} );
 exit unless defined $args;
 
 my %args = %$args;
@@ -300,40 +298,39 @@
 print_introduction($parrot_version);
 
 my $conf = Parrot::Configure->new;
-{
 
-    # RT#41201 $Parrot::Configure::Step::conf is a temporary hack
-    no warnings qw(once);
-    $Parrot::Configure::Step::conf = $conf;
-}
-
 # from Parrot::Configure::Step::List
 $conf->add_steps(get_steps_list());
 
+# from Parrot::Configure::Data
 $conf->options->set(%args);
 
 if ( exists $args{step} ) {
+    # from Parrot::Configure::Data
     $conf->data()->slurp();
+    # from Parrot::Configure
     $conf->runstep( $args{step} );
     print "\n";
-    exit(0);
 }
 else {
-
     # Run the actual steps
+    # from Parrot::Configure
     $conf->runsteps or exit(1);
 }
 
 # tell users what to do next
-
 # from Parrot::Configure::Messages
-print_conclusion( $conf->data->get('make') );
+print_conclusion($conf->data->get('make'));
 
 exit(0);
 
+################### DOCUMENTATION ###################
+
+
 # Local Variables:
 #   mode: cperl
 #   cperl-indent-level: 4
 #   fill-column: 100
 # End:
 # vim: expandtab shiftwidth=4:
+
Index: lib/Parrot/Configure.pm
===================================================================
--- lib/Parrot/Configure.pm	(revision 18347)
+++ lib/Parrot/Configure.pm	(working copy)
@@ -1,8 +1,6 @@
 # Copyright (C) 2001-2006, The Perl Foundation.
 # $Id$
 
-=pod
-
 =head1 NAME
 
 Parrot::Configure - Conducts the execution of Configuration Steps
@@ -67,18 +65,19 @@
 
 =cut
 
-sub new {
-    my $class = shift;
-
-    my $self = {
+my $singleton;
+BEGIN {
+    $singleton = {
         steps   => [],
         data    => Parrot::Configure::Data->new,
         options => Parrot::Configure::Data->new,
     };
+    bless $singleton, "Parrot::Configure";
+}
 
-    bless $self, ref $class || $class;
-
-    return $self;
+sub new {
+    my $class = shift;
+    return $singleton;
 }
 
 =back
@@ -136,11 +135,12 @@
 
 =item * C<add_step()>
 
-Registers a new step and any parameters that should be passed to it.  With the
-first parameter being the class name of the step register.  All other
-parameters are saved and passed to the registered class's C<runstep()> method.
+Registers a new step and any parameters that should be passed to it.  The
+first parameter passed is the class name of the step being registered.  All
+other parameters are saved and passed to the registered class's C<runstep()>
+method.
 
-Accepts a list and returns a L<Parrot::Configure> object.
+Accepts a list and modifies the data structure within the L<Parrot::Configure> object.
 
 =cut
 
@@ -149,14 +149,14 @@
 
     push @{ $self->{steps} }, Parrot::Configure::Task->new( step => $step, params => \@params );
 
-    return $self;
+    return 1;
 }
 
 =item * C<add_steps()>
 
-Registers a new step to be run at the end of the execution queue.
+Registers new steps to be run at the end of the execution queue.
 
-Accepts a list and returns a L<Parrot::Configure> object.
+Accepts a list of new steps and modifies the data structure within the L<Parrot::Configure> object.
 
 =cut
 
@@ -167,17 +167,17 @@
         $self->add_step($step);
     }
 
-    return $self;
+    return 1;
 }
 
 =item * C<runsteps()>
 
-Sequentially executes step in the order they were registered.  The invoking
-L<Parrot::Configure> object is passed as the first argument to each steps
-C<runstep()> method followed by any parameters that were registered for that
+Sequentially executes steps in the order they were registered.  The invoking
+L<Parrot::Configure> object is passed as the first argument to each step's
+C<runstep()> method, followed by any parameters that were registered for that
 step.
 
-Accepts no arguments and returns a L<Parrot::Configure> object.
+Accepts no arguments and modifies the data structure within the L<Parrot::Configure> object.
 
 =cut
 
@@ -191,17 +191,16 @@
         $n++;
         $self->_runstep( $task, $verbose, $verbose_step, $ask, $n );
     }
-    return $self;
+    return 1;
 }
 
 =item * C<runstep()>
 
-The invoking
-L<Parrot::Configure> object is passed as the first argument to each steps
-C<runstep()> method followed by any parameters that were registered for that
-step.
+The invoking L<Parrot::Configure> object is passed as the first argument to
+each step's C<runstep()> method, followed by any parameters that were
+registered for that step.
 
-Accepts no arguments and returns a L<Parrot::Configure> object.
+Accepts no arguments and modifies the data structure within the L<Parrot::Configure> object.
 
 =cut
 
Index: lib/Parrot/Configure/Data.pm
===================================================================
--- lib/Parrot/Configure/Data.pm	(revision 18347)
+++ lib/Parrot/Configure/Data.pm	(working copy)
@@ -177,7 +177,7 @@
 
 sub slurp() {
     my $self = shift;
-    my $res  = eval "no strict; use Parrot::Config; \\%PConfig";
+    my $res  = eval "no strict; use Parrot::Config::Generated; \\%PConfig";
 
     if ( not defined $res ) {
         die "You cannot use --step until you have completed the full configure process\n";
Index: lib/Parrot/Configure/Step.pm
===================================================================
--- lib/Parrot/Configure/Step.pm	(revision 18347)
+++ lib/Parrot/Configure/Step.pm	(working copy)
@@ -33,9 +33,10 @@
 use File::Copy ();
 use File::Spec;
 use File::Which;
+use lib ("lib");
+use Parrot::Configure;
 
-# XXX $conf is a temporary hack
-our $conf;
+my $conf = Parrot::Configure->new();
 
 our @EXPORT    = ();
 our @EXPORT_OK = qw(prompt genfile copy_if_diff move_if_diff integrate
Index: t/harness
===================================================================
--- t/harness	(revision 18347)
+++ t/harness	(working copy)
@@ -153,7 +153,7 @@
 
 # Pass in a list of tests to run on the command line, else run all the tests.
 my @default_tests = map {glob "t/$_/*.t"} qw(
-    configure compilers/imcc/* op pmc native_pbc dynpmc dynoplibs
+    configure postconfigure compilers/imcc/* op pmc native_pbc dynpmc dynoplibs
     compilers/past compilers/pge compilers/pge/p5regex compilers/pge/p6regex
     compilers/tge compilers/json library examples run src tools perl doc stm
 );
Index: config/init/defaults.pm
===================================================================
--- config/init/defaults.pm	(revision 18347)
+++ config/init/defaults.pm	(working copy)
@@ -22,6 +22,7 @@
 use Config;
 use FindBin;    # see build_dir
 use Parrot::Configure::Step;
+use Parrot::BuildUtil;
 use Cwd qw(abs_path);
 use File::Spec;
 
@@ -29,6 +30,9 @@
 
 @args = qw(debugging optimize profile verbose m);
 
+my $parrot_version = Parrot::BuildUtil::parrot_version();
+my @parrot_version = Parrot::BuildUtil::parrot_version();
+
 sub runstep {
     my ( $self, $conf ) = @_;
 
@@ -169,10 +173,10 @@
         lns   => $Config{lns},                          # soft link
         slash => '/',
 
-        VERSION => $main::parrot_version,
-        MAJOR   => $main::parrot_version[0],
-        MINOR   => $main::parrot_version[1],
-        PATCH   => $main::parrot_version[2],
+        VERSION => $parrot_version,
+        MAJOR   => $parrot_version[0],
+        MINOR   => $parrot_version[1],
+        PATCH   => $parrot_version[2],
         DEVEL   => ( -e 'DEVELOPING' ? '-devel' : '' ),
 
         configdate => scalar gmtime() . " GMT",
Index: MANIFEST
===================================================================
--- MANIFEST	(revision 18347)
+++ MANIFEST	(working copy)
@@ -2790,11 +2790,31 @@
 t/configure/01-options.t                                    []
 t/configure/02-messages.t                                   []
 t/configure/03-steplist.t                                   []
+t/configure/04-configure.t                                  []
+t/configure/05-run_one_step.t                               []
+t/configure/06-bad_step.t                                   []
+t/configure/07-verbose_two.t                                []
+t/configure/08-verbose_step_number.t                        []
+t/configure/09-verbose_step_regex.t                         []
+t/configure/10-verbose_step_number_not_called.t             []
+t/configure/11-no_description.t                             []
+t/configure/12-verbose.t                                    []
+t/configure/13-die.t                                        []
+t/configure/14-params.t                                     []
+t/configure/15-no_return.t                                  []
+t/configure/16-no_return_but_result.t                       []
 t/configure/base.t                                          []
 t/configure/config_steps.t                                  []
-t/configure/configure.t                                     []
 t/configure/data.t                                          []
 t/configure/step.t                                          []
+t/configure/testlib/init/alpha.pm                           []
+t/configure/testlib/init/beta.pm                            []
+t/configure/testlib/init/delta.pm                           []
+t/configure/testlib/init/epsilon.pm                         []
+t/configure/testlib/init/foobar.pm                          []
+t/configure/testlib/init/gamma.pm                           []
+t/configure/testlib/init/zeta.pm                            []
+t/postconfigure/01-data_slurp.t                             []
 t/distro/file_metadata.t                                    []
 t/distro/manifest.t                                         []
 t/distro/manifest_skip.t                                    []
Index: t/configure/09-verbose_step_regex.t
===================================================================
--- t/configure/09-verbose_step_regex.t	(revision 0)
+++ t/configure/09-verbose_step_regex.t	(revision 0)
@@ -0,0 +1,110 @@
+#! perl
+# Copyright (C) 2007, The Perl Foundation.
+# $Id: 09-verbose_step_regex.t 18310 2007-04-24 01:27:22Z jkeenan $
+# 09-verbose_step_regex.t
+
+use strict;
+use warnings;
+
+use Test::More tests => 14;
+use Carp;
+use lib qw( . lib ../lib ../../lib t/configure/testlib );
+use Parrot::BuildUtil;
+use Parrot::Configure;
+use Parrot::Configure::Options qw( process_options );
+use Parrot::IO::Capture::Mini;
+
+my $parrot_version = Parrot::BuildUtil::parrot_version();
+like($parrot_version, qr/\d+\.\d+\.\d+/,
+    "Parrot version is in 3-part format");
+
+$| = 1;
+is($|, 1, "output autoflush is set");
+
+my $args = process_options( {
+    argv            => [ q{--verbose-step=foobar} ],
+    script          => $0,
+    parrot_version  => $parrot_version,
+    svnid           => '$Id: 09-verbose_step_regex.t 18310 2007-04-24 01:27:22Z jkeenan $',
+} );
+ok(defined $args, "process_options returned successfully");
+my %args = %$args;
+
+my $conf = Parrot::Configure->new;
+ok(defined $conf, "Parrot::Configure->new() returned okay");
+
+my $step = q{init::foobar};
+my $description = 'Determining if your computer does foobar';
+
+$conf->add_steps( $step );
+my @confsteps = @{$conf->steps};
+isnt(scalar @confsteps, 0,
+    "Parrot::Configure object 'steps' key holds non-empty array reference");
+is(scalar @confsteps, 1,
+    "Parrot::Configure object 'steps' key holds ref to 1-element array");
+my $nontaskcount = 0;
+foreach my $k (@confsteps) {
+    $nontaskcount++ unless $k->isa("Parrot::Configure::Task");
+}
+is($nontaskcount, 0, "Each step is a Parrot::Configure::Task object");
+is($confsteps[0]->step, $step, 
+    "'step' element of Parrot::Configure::Task struct identified");
+is(ref($confsteps[0]->params), 'ARRAY',
+    "'params' element of Parrot::Configure::Task struct is array ref");
+ok(! ref($confsteps[0]->object),
+    "'object' element of Parrot::Configure::Task struct is not yet a ref");
+
+$conf->options->set(%args);
+is($conf->options->{c}->{debugging}, 1,
+    "command-line option '--debugging' has been stored in object");
+
+my $rv;
+my ($tie, @lines);
+{
+    $tie = tie *STDOUT, "Parrot::IO::Capture::Mini"
+        or croak "Unable to tie";
+    $rv = $conf->runsteps;
+    @lines = $tie->READLINE;
+}
+ok($rv, "runsteps successfully ran $step");
+my $bigmsg = join q{}, @lines;
+like($bigmsg,
+    qr/$description\.\.\..*done.*Setting Configuration Data.*verbose.*undef/s,
+    "Got message expected upon running $step");
+
+pass("Completed all tests in $0");
+
+################### DOCUMENTATION ###################
+
+=head1 NAME
+
+09-verbose_step_regex.t - test bad step failure case in Parrot::Configure
+
+=head1 SYNOPSIS
+
+    % prove t/configure09-verbose_step_regex.t
+
+=head1 DESCRIPTION
+
+The files in this directory test functionality used by F<Configure.pl>.
+
+The tests in this file examine what happens when you configure with the
+<--verbose-step> option set to match the description associated with step
+C<init::manifest>.
+
+=head1 AUTHOR
+
+James E Keenan
+
+=head1 SEE ALSO
+
+Parrot::Configure, F<Configure.pl>.
+
+=cut
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/configure.t
===================================================================
--- t/configure/configure.t	(revision 18347)
+++ t/configure/configure.t	(working copy)
@@ -1,278 +0,0 @@
-#!perl
-# Copyright (C) 2001-2005, The Perl Foundation.
-# $Id$
-
-use strict;
-use warnings;
-
-use lib qw( . lib ../lib ../../lib );
-use Test::More tests => 32;
-
-=head1 NAME
-
-t/configure/configure.t - tests Parrot::Configure
-
-=head1 SYNOPSIS
-
-    prove t/configure/configure.t
-
-=head1 DESCRIPTION
-
-Regressions tests for the L<Parrot::Configure> class.
-
-=cut
-
-BEGIN { use_ok('Parrot::Configure'); }
-
-can_ok(
-    'Parrot::Configure', qw(
-        new
-        data
-        options
-        steps
-        add_steps
-        runsteps
-        )
-);
-
-# ->new()
-
-{
-    my $pc = Parrot::Configure->new;
-
-    isa_ok( $pc, 'Parrot::Configure' );
-}
-
-# ->data()
-
-{
-    my $pc = Parrot::Configure->new;
-
-    isa_ok( $pc->data, 'Parrot::Configure::Data' );
-}
-
-# ->options()
-
-{
-    my $pc = Parrot::Configure->new;
-
-    isa_ok( $pc->options, 'Parrot::Configure::Data' );
-}
-
-# ->steps() / ->add_steps()
-
-{
-    my $pc = Parrot::Configure->new;
-
-    isa_ok( $pc->add_steps(), 'Parrot::Configure' );
-}
-
-{
-    my $pc = Parrot::Configure->new;
-
-    is_deeply( scalar $pc->steps, [], "->steps() returns array ref in scalar context" );
-}
-
-{
-    my $pc = Parrot::Configure->new;
-
-    is_deeply( [ $pc->steps ], [], "->steps() returns () in list context" );
-}
-
-{
-    my $pc = Parrot::Configure->new;
-
-    $pc->add_steps(qw(foo::step));
-    my $steps = $pc->steps;
-    is( scalar @$steps, 1, '->steps() retuned the proper number of steps' );
-    my $task = @$steps[0];
-    is( $task->step, 'foo::step', '->steps() returned a task with the proper step name' );
-    is_deeply( $task->params, [], '->steps() return a task with the proper params' );
-}
-
-{
-    my $pc = Parrot::Configure->new;
-
-    $pc->add_steps(qw(foo::step bar::step baz::step));
-    my $steps = $pc->steps;
-    is( scalar @$steps, 3, '->steps() retuned the proper number of steps' );
-    is_deeply( $pc->steps->[0]->step,
-        'foo::step', '->steps() returned a task with the proper step name' );
-    is_deeply( $pc->steps->[1]->step,
-        'bar::step', '->steps() returned a task with the proper step name' );
-    is_deeply( $pc->steps->[2]->step,
-        'baz::step', '->steps() returned a task with the proper step name' );
-}
-
-# ->steps() / ->add_step()
-
-{
-    my $pc = Parrot::Configure->new;
-
-    isa_ok( $pc->add_step(), 'Parrot::Configure' );
-}
-
-{
-    my $pc = Parrot::Configure->new;
-
-    $pc->add_step('foo::step');
-    my $steps = $pc->steps;
-    is( scalar @$steps, 1, '->steps() retuned the proper number of steps' );
-    my $task = @$steps[0];
-    is( $task->step, 'foo::step', '->steps() returned a task with the proper step name' );
-    is_deeply( $task->params, [], '->steps() return a task with the proper params' );
-}
-
-{
-    my $pc = Parrot::Configure->new;
-
-    $pc->add_step( 'foo::step', qw(bar baz) );
-    my $steps = $pc->steps;
-    is( scalar @$steps, 1, '->steps() retuned the proper number of steps' );
-    my $task = @$steps[0];
-    is( $task->step, 'foo::step', '->steps() returned a task with the proper step name' );
-    is_deeply( $task->params, [qw(bar baz)],
-        '->steps() return a task with the proper params after ->add_step() with args' );
-}
-
-# ->runsteps()
-
-{
-    my $pc = Parrot::Configure->new;
-
-    isa_ok( $pc->runsteps, 'Parrot::Configure' );
-}
-
-{
-
-    package test::step;
-
-    # XXX is there a better way of doing this?
-    $INC{'test/step.pm'}++;
-
-    use vars qw($ran);
-    use base qw(Parrot::Configure::Step::Base);
-
-    $ran = 0;
-
-    sub runstep {
-        my ( $self, $conf ) = @_;
-
-        $ran = 1;
-
-        return $self;
-    }
-
-    package main;
-
-    my $pc = Parrot::Configure->new;
-
-    $pc->add_steps('test::step');
-    $pc->runsteps;
-
-    # otherwise runsteps() output will make Test::Harness think this test
-    # failed.
-    print "\n";
-    is( $test::step::ran, 1, "test step was invokved" );
-}
-
-{
-
-    package test::step::params;
-
-    # XXX is there a better way of doing this?
-    $INC{'test/step/params.pm'}++;
-
-    use vars qw($self $conf @params);
-    use base qw(Parrot::Configure::Step::Base);
-
-    sub runstep {
-        ( $self, $conf, @params ) = @_;
-        return $self;
-    }
-
-    package main;
-
-    my $pc = Parrot::Configure->new;
-
-    $pc->add_steps('test::step::params');
-    $pc->runsteps;
-
-    # otherwise runsteps() output will make Test::Harness think this test
-    # failed.
-    print "\n";
-    isa_ok( $test::step::params::self, 'test::step::params' );
-    isa_ok( $test::step::params::conf, 'Parrot::Configure' );
-    is_deeply( \@test::step::params::conf, [], "no extra parameters were passed to ->runstep()" );
-}
-
-{
-
-    package test::step::stepparams;
-
-    # XXX is there a better way of doing this?
-    $INC{'test/step/stepparams.pm'}++;
-
-    use vars qw($self $conf @params);
-    use base qw(Parrot::Configure::Step::Base);
-
-    sub runstep {
-        ( $self, $conf, @params ) = @_;
-        return $self;
-    }
-
-    package main;
-
-    my $pc = Parrot::Configure->new;
-
-    $pc->add_step( 'test::step::stepparams', 24, qw( bar baz bong ), 42 );
-    $pc->runsteps;
-
-    # otherwise runsteps() output will make Test::Harness think this test
-    # failed.
-    print "\n";
-    isa_ok( $test::step::stepparams::self, 'test::step::stepparams' );
-    isa_ok( $test::step::stepparams::conf, 'Parrot::Configure' );
-    cmp_ok( $test::step::stepparams::self, 'ne', $test::step::stepparams::conf,
-        '$self and $conf params are not the same object' );
-    is_deeply(
-        \@test::step::stepparams::params,
-        [ 24, qw( bar baz bong ), 42 ],
-        'proper additional parameters were passed to ->runstep()'
-    );
-}
-
-{
-
-    package test::step::stepfail;
-
-    # XXX is there a better way of doing this?
-    $INC{'test/step/stepfail.pm'}++;
-
-    use vars qw($self $conf @params);
-    use base qw(Parrot::Configure::Step::Base);
-
-    sub runstep {
-        return;
-    }
-
-    package main;
-
-    my $pc = Parrot::Configure->new();
-
-    # send warnings to stdout
-    open *STDERR, ">&STDOUT" or die "Can't dup STDOUT: $!";
-
-    $pc->add_step('test::step::stepfail');
-    my $ret = $pc->runsteps();
-    print "\n";
-    is( ref $ret, 'Parrot::Configure',
-        '->runsteps() returns even on failure a Parrot::Configure instance' );
-}
-
-# Local Variables:
-#   mode: cperl
-#   cperl-indent-level: 4
-#   fill-column: 100
-# End:
-# vim: expandtab shiftwidth=4:
Index: t/configure/13-die.t
===================================================================
--- t/configure/13-die.t	(revision 0)
+++ t/configure/13-die.t	(revision 0)
@@ -0,0 +1,114 @@
+#! perl
+# Copyright (C) 2007, The Perl Foundation.
+# $Id: 13-die.t 18310 2007-04-24 01:27:22Z jkeenan $
+# 13-die.t
+
+use strict;
+use warnings;
+
+use Test::More qw(no_plan); # tests => 14;
+use Carp;
+use lib qw( . lib ../lib ../../lib t/configure/testlib );
+use Parrot::BuildUtil;
+use Parrot::Configure;
+use Parrot::Configure::Options qw( process_options );
+use Parrot::IO::Capture::Mini;
+
+my $parrot_version = Parrot::BuildUtil::parrot_version();
+like($parrot_version, qr/\d+\.\d+\.\d+/,
+    "Parrot version is in 3-part format");
+
+$| = 1;
+is($|, 1, "output autoflush is set");
+
+my $args = process_options( {
+    argv            => [ ],
+    script          => $0,
+    parrot_version  => $parrot_version,
+    svnid           => '$Id: 13-die.t 18310 2007-04-24 01:27:22Z jkeenan $',
+} );
+ok(defined $args, "process_options returned successfully");
+my %args = %$args;
+
+my $conf = Parrot::Configure->new;
+ok(defined $conf, "Parrot::Configure->new() returned okay");
+
+my $step = q{init::gamma};
+my $description = 'Determining if your computer does gamma';
+
+$conf->add_steps( $step );
+my @confsteps = @{$conf->steps};
+isnt(scalar @confsteps, 0,
+    "Parrot::Configure object 'steps' key holds non-empty array reference");
+is(scalar @confsteps, 1,
+    "Parrot::Configure object 'steps' key holds ref to 1-element array");
+my $nontaskcount = 0;
+foreach my $k (@confsteps) {
+    $nontaskcount++ unless $k->isa("Parrot::Configure::Task");
+}
+is($nontaskcount, 0, "Each step is a Parrot::Configure::Task object");
+is($confsteps[0]->step, $step, 
+    "'step' element of Parrot::Configure::Task struct identified");
+is(ref($confsteps[0]->params), 'ARRAY',
+    "'params' element of Parrot::Configure::Task struct is array ref");
+ok(! ref($confsteps[0]->object),
+    "'object' element of Parrot::Configure::Task struct is not yet a ref");
+
+$conf->options->set(%args);
+is($conf->options->{c}->{debugging}, 1,
+    "command-line option '--debugging' has been stored in object");
+
+my $rv;
+my ($tie, @lines, $errstr);
+{
+    $tie = tie *STDOUT, "Parrot::IO::Capture::Mini"
+        or croak "Unable to tie";
+    local $SIG{__WARN__} = \&_capture;
+    eval { $rv = $conf->runsteps; };
+    @lines = $tie->READLINE;
+}
+my $bigmsg = join q{}, @lines;
+like($bigmsg,
+    qr/$description/s,
+    "Got message expected upon running $step");
+like($errstr,
+    qr/step $step died during execution: Dying gamma just to see what happens/,
+    "Got expected error message");
+
+pass("Completed all tests in $0");
+
+sub _capture { $errstr = $_[0];}
+
+################### DOCUMENTATION ###################
+
+=head1 NAME
+
+13-die.t - test what happens when a configuration step dies during execution
+
+=head1 SYNOPSIS
+
+    % prove t/configure13-die.t
+
+=head1 DESCRIPTION
+
+The files in this directory test functionality used by F<Configure.pl>.
+
+The tests in this file examine what happens when your configuration step dies
+during execution.
+
+=head1 AUTHOR
+
+James E Keenan
+
+=head1 SEE ALSO
+
+Parrot::Configure, F<Configure.pl>.
+
+=cut
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/05-run_one_step.t
===================================================================
--- t/configure/05-run_one_step.t	(revision 0)
+++ t/configure/05-run_one_step.t	(revision 0)
@@ -0,0 +1,126 @@
+#! perl
+# Copyright (C) 2007, The Perl Foundation.
+# $Id: 05-run_one_step.t 18310 2007-04-24 01:27:22Z jkeenan $
+# 05-run_one_step.t
+
+use strict;
+use warnings;
+
+use Test::More tests => 23;
+use Carp;
+use lib qw( . lib ../lib ../../lib t/configure/testlib );
+use Parrot::BuildUtil;
+use Parrot::Configure;
+use Parrot::Configure::Options qw( process_options );
+use Parrot::IO::Capture::Mini;
+
+my $parrot_version = Parrot::BuildUtil::parrot_version();
+like($parrot_version, qr/\d+\.\d+\.\d+/,
+    "Parrot version is in 3-part format");
+
+$| = 1;
+is($|, 1, "output autoflush is set");
+
+my $args = process_options( {
+    argv            => [],
+    script          => $0,
+    parrot_version  => $parrot_version,
+    svnid           => '$Id: 05-run_one_step.t 18310 2007-04-24 01:27:22Z jkeenan $',
+} );
+ok(defined $args, "process_options returned successfully");
+my %args = %$args;
+
+my $conf = Parrot::Configure->new;
+ok(defined $conf, "Parrot::Configure->new() returned okay");
+
+my $newconf = Parrot::Configure->new;
+ok(defined $newconf, "Parrot::Configure->new() returned okay");
+is($conf, $newconf, "Parrot::Configure object is a singleton");
+
+# Since these tests peek into the Parrot::Configure object, they will break if
+# the structure of that object changes.  We retain them for now to delineate
+# our progress in testing the object.
+foreach my $k (qw| steps options data |) {
+    ok(defined $conf->$k, "Parrot::Configure object has $k key");
+}
+is(ref($conf->steps), q{ARRAY},
+    "Parrot::Configure object 'steps' key is array reference");
+is(scalar @{$conf->steps}, 0,
+    "Parrot::Configure object 'steps' key holds empty array reference");
+foreach my $k (qw| options data |) {
+    isa_ok($conf->$k, "Parrot::Configure::Data");
+}
+
+my $step = q{init::foobar};
+my $description = 'Determining if your computer does foobar';
+
+$conf->add_steps( $step );
+my @confsteps = @{$conf->steps};
+isnt(scalar @confsteps, 0,
+    "Parrot::Configure object 'steps' key holds non-empty array reference");
+is(scalar @confsteps, 1,
+    "Parrot::Configure object 'steps' key holds ref to 1-element array");
+my $nontaskcount = 0;
+foreach my $k (@confsteps) {
+    $nontaskcount++ unless $k->isa("Parrot::Configure::Task");
+}
+is($nontaskcount, 0, "Each step is a Parrot::Configure::Task object");
+is($confsteps[0]->step, $step, 
+    "'step' element of Parrot::Configure::Task struct identified");
+is(ref($confsteps[0]->params), 'ARRAY',
+    "'params' element of Parrot::Configure::Task struct is array ref");
+ok(! ref($confsteps[0]->object),
+    "'object' element of Parrot::Configure::Task struct is not yet a ref");
+
+$conf->options->set(%args);
+is($conf->options->{c}->{debugging}, 1,
+    "command-line option '--debugging' has been stored in object");
+
+my $rv;
+my ($tie, $msg);
+{
+    $tie = tie *STDOUT, "Parrot::IO::Capture::Mini"
+        or croak "Unable to tie";
+    $rv = $conf->runsteps;
+    $msg = $tie->READLINE;
+}
+ok($rv, "runsteps successfully ran $step");
+like($msg, qr/$description/,
+    "Got message expected upon running $step");
+
+pass("Completed all tests in $0");
+
+################### DOCUMENTATION ###################
+
+=head1 NAME
+
+05-run_one_step.t - test Parrot::Configure by running one step
+
+=head1 SYNOPSIS
+
+    % prove t/configure05-run_one_step.t
+
+=head1 DESCRIPTION
+
+The files in this directory test functionality used by F<Configure.pl>.
+
+The tests in this file test those Parrot::Configure methods regularly called
+by F<Configure.pl> up to C<Parrot::Configure::runsteps()> but providing only
+one step instead of the regular full set.
+
+=head1 AUTHOR
+
+James E Keenan
+
+=head1 SEE ALSO
+
+Parrot::Configure, F<Configure.pl>.
+
+=cut
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/07-verbose_two.t
===================================================================
--- t/configure/07-verbose_two.t	(revision 0)
+++ t/configure/07-verbose_two.t	(revision 0)
@@ -0,0 +1,113 @@
+#! perl
+# Copyright (C) 2007, The Perl Foundation.
+# $Id: 07-verbose_two.t 18310 2007-04-24 01:27:22Z jkeenan $
+# 07-verbose_two.t
+
+use strict;
+use warnings;
+
+use Test::More tests => 14;
+use Carp;
+use lib qw( . lib ../lib ../../lib t/configure/testlib );
+use Parrot::BuildUtil;
+use Parrot::Configure;
+use Parrot::Configure::Options qw( process_options );
+use Parrot::IO::Capture::Mini;
+
+my $parrot_version = Parrot::BuildUtil::parrot_version();
+like($parrot_version, qr/\d+\.\d+\.\d+/,
+    "Parrot version is in 3-part format");
+
+$| = 1;
+is($|, 1, "output autoflush is set");
+
+my $args = process_options( {
+    argv            => [ q{--verbose=2} ],
+    script          => $0,
+    parrot_version  => $parrot_version,
+    svnid           => '$Id: 07-verbose_two.t 18310 2007-04-24 01:27:22Z jkeenan $',
+} );
+ok(defined $args, "process_options returned successfully");
+my %args = %$args;
+
+my $conf = Parrot::Configure->new;
+ok(defined $conf, "Parrot::Configure->new() returned okay");
+
+my $step = q{init::foobar};
+my $description = 'Determining if your computer does foobar';
+
+$conf->add_steps( $step );
+my @confsteps = @{$conf->steps};
+isnt(scalar @confsteps, 0,
+    "Parrot::Configure object 'steps' key holds non-empty array reference");
+is(scalar @confsteps, 1,
+    "Parrot::Configure object 'steps' key holds ref to 1-element array");
+my $nontaskcount = 0;
+foreach my $k (@confsteps) {
+    $nontaskcount++ unless $k->isa("Parrot::Configure::Task");
+}
+is($nontaskcount, 0, "Each step is a Parrot::Configure::Task object");
+is($confsteps[0]->step, $step, 
+    "'step' element of Parrot::Configure::Task struct identified");
+is(ref($confsteps[0]->params), 'ARRAY',
+    "'params' element of Parrot::Configure::Task struct is array ref");
+ok(! ref($confsteps[0]->object),
+    "'object' element of Parrot::Configure::Task struct is not yet a ref");
+
+$conf->options->set(%args);
+is($conf->options->{c}->{debugging}, 1,
+    "command-line option '--debugging' has been stored in object");
+
+my $rv;
+my ($tie, @lines);
+{
+    $tie = tie *STDOUT, "Parrot::IO::Capture::Mini"
+        or croak "Unable to tie";
+    $rv = $conf->runsteps;
+    @lines = $tie->READLINE;
+}
+ok($rv, "runsteps successfully ran $step");
+my $bigmsg = join q{}, @lines;
+like($bigmsg,
+    qr/$description\.\.\..*done.*Setting Configuration Data.*verbose.*2/s,
+    "Got message expected upon running $step");
+
+pass("Completed all tests in $0");
+
+################### DOCUMENTATION ###################
+
+=head1 NAME
+
+07-verbose_two.t - test bad step failure case in Parrot::Configure
+
+=head1 SYNOPSIS
+
+    % prove t/configure07-verbose_two.t
+
+=head1 DESCRIPTION
+
+The files in this directory test functionality used by F<Configure.pl>.
+
+The tests in this file examine what happens when you configure with the
+<--verbose> option set to C<2>.
+
+(Since I am testing with only the first step, C<init::manifest>, and since that
+step has nothing to say when C<--verbose=1>, I have to advance to
+C<--verbose=2>.)
+
+=head1 AUTHOR
+
+James E Keenan
+
+=head1 SEE ALSO
+
+Parrot::Configure, F<Configure.pl>.
+
+=cut
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/12-verbose.t
===================================================================
--- t/configure/12-verbose.t	(revision 0)
+++ t/configure/12-verbose.t	(revision 0)
@@ -0,0 +1,109 @@
+#! perl
+# Copyright (C) 2007, The Perl Foundation.
+# $Id: 12-verbose.t 18310 2007-04-24 01:27:22Z jkeenan $
+# 12-verbose.t
+
+use strict;
+use warnings;
+
+use Test::More tests => 14;
+use Carp;
+use lib qw( . lib ../lib ../../lib t/configure/testlib );
+use Parrot::BuildUtil;
+use Parrot::Configure;
+use Parrot::Configure::Options qw( process_options );
+use Parrot::IO::Capture::Mini;
+
+my $parrot_version = Parrot::BuildUtil::parrot_version();
+like($parrot_version, qr/\d+\.\d+\.\d+/,
+    "Parrot version is in 3-part format");
+
+$| = 1;
+is($|, 1, "output autoflush is set");
+
+my $args = process_options( {
+    argv            => [ q{--verbose} ],
+    script          => $0,
+    parrot_version  => $parrot_version,
+    svnid           => '$Id: 12-verbose.t 18310 2007-04-24 01:27:22Z jkeenan $',
+} );
+ok(defined $args, "process_options returned successfully");
+my %args = %$args;
+
+my $conf = Parrot::Configure->new;
+ok(defined $conf, "Parrot::Configure->new() returned okay");
+
+my $step = q{init::beta};
+my $description = 'Determining if your computer does beta';
+
+$conf->add_steps( $step );
+my @confsteps = @{$conf->steps};
+isnt(scalar @confsteps, 0,
+    "Parrot::Configure object 'steps' key holds non-empty array reference");
+is(scalar @confsteps, 1,
+    "Parrot::Configure object 'steps' key holds ref to 1-element array");
+my $nontaskcount = 0;
+foreach my $k (@confsteps) {
+    $nontaskcount++ unless $k->isa("Parrot::Configure::Task");
+}
+is($nontaskcount, 0, "Each step is a Parrot::Configure::Task object");
+is($confsteps[0]->step, $step, 
+    "'step' element of Parrot::Configure::Task struct identified");
+is(ref($confsteps[0]->params), 'ARRAY',
+    "'params' element of Parrot::Configure::Task struct is array ref");
+ok(! ref($confsteps[0]->object),
+    "'object' element of Parrot::Configure::Task struct is not yet a ref");
+
+$conf->options->set(%args);
+is($conf->options->{c}->{debugging}, 1,
+    "command-line option '--debugging' has been stored in object");
+
+my $rv;
+my ($tie, @lines);
+{
+    $tie = tie *STDOUT, "Parrot::IO::Capture::Mini"
+        or croak "Unable to tie";
+    $rv = $conf->runsteps;
+    @lines = $tie->READLINE;
+}
+ok($rv, "runsteps successfully ran $step");
+my $bigmsg = join q{}, @lines;
+like($bigmsg,
+    qr/$description\.\.\..*beta is verbose.*You've got beta.*done\./s, #'
+    "Got message expected upon running $step");
+
+pass("Completed all tests in $0");
+
+################### DOCUMENTATION ###################
+
+=head1 NAME
+
+12-verbose.t - test the C<--verbose> command-line argument
+
+=head1 SYNOPSIS
+
+    % prove t/configure12-verbose.t
+
+=head1 DESCRIPTION
+
+The files in this directory test functionality used by F<Configure.pl>.
+
+The tests in this file examine what happens when you configure with
+C<--verbose>.
+
+=head1 AUTHOR
+
+James E Keenan
+
+=head1 SEE ALSO
+
+Parrot::Configure, F<Configure.pl>.
+
+=cut
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/08-verbose_step_number.t
===================================================================
--- t/configure/08-verbose_step_number.t	(revision 0)
+++ t/configure/08-verbose_step_number.t	(revision 0)
@@ -0,0 +1,109 @@
+#! perl
+# Copyright (C) 2007, The Perl Foundation.
+# $Id: 08-verbose_step_number.t 18310 2007-04-24 01:27:22Z jkeenan $
+# 08-verbose_step_number.t
+
+use strict;
+use warnings;
+
+use Test::More tests => 14;
+use Carp;
+use lib qw( . lib ../lib ../../lib t/configure/testlib );
+use Parrot::BuildUtil;
+use Parrot::Configure;
+use Parrot::Configure::Options qw( process_options );
+use Parrot::IO::Capture::Mini;
+
+my $parrot_version = Parrot::BuildUtil::parrot_version();
+like($parrot_version, qr/\d+\.\d+\.\d+/,
+    "Parrot version is in 3-part format");
+
+$| = 1;
+is($|, 1, "output autoflush is set");
+
+my $args = process_options( {
+    argv            => [ q{--verbose-step=1} ],
+    script          => $0,
+    parrot_version  => $parrot_version,
+    svnid           => '$Id: 08-verbose_step_number.t 18310 2007-04-24 01:27:22Z jkeenan $',
+} );
+ok(defined $args, "process_options returned successfully");
+my %args = %$args;
+
+my $conf = Parrot::Configure->new;
+ok(defined $conf, "Parrot::Configure->new() returned okay");
+
+my $step = q{init::foobar};
+my $description = 'Determining if your computer does foobar';
+
+$conf->add_steps( $step );
+my @confsteps = @{$conf->steps};
+isnt(scalar @confsteps, 0,
+    "Parrot::Configure object 'steps' key holds non-empty array reference");
+is(scalar @confsteps, 1,
+    "Parrot::Configure object 'steps' key holds ref to 1-element array");
+my $nontaskcount = 0;
+foreach my $k (@confsteps) {
+    $nontaskcount++ unless $k->isa("Parrot::Configure::Task");
+}
+is($nontaskcount, 0, "Each step is a Parrot::Configure::Task object");
+is($confsteps[0]->step, $step, 
+    "'step' element of Parrot::Configure::Task struct identified");
+is(ref($confsteps[0]->params), 'ARRAY',
+    "'params' element of Parrot::Configure::Task struct is array ref");
+ok(! ref($confsteps[0]->object),
+    "'object' element of Parrot::Configure::Task struct is not yet a ref");
+
+$conf->options->set(%args);
+is($conf->options->{c}->{debugging}, 1,
+    "command-line option '--debugging' has been stored in object");
+
+my $rv;
+my ($tie, @lines);
+{
+    $tie = tie *STDOUT, "Parrot::IO::Capture::Mini"
+        or croak "Unable to tie";
+    $rv = $conf->runsteps;
+    @lines = $tie->READLINE;
+}
+ok($rv, "runsteps successfully ran $step");
+my $bigmsg = join q{}, @lines;
+like($bigmsg,
+    qr/$description\.\.\..*done.*Setting Configuration Data.*verbose.*undef/s,
+    "Got message expected upon running $step");
+
+pass("Completed all tests in $0");
+
+################### DOCUMENTATION ###################
+
+=head1 NAME
+
+08-verbose_step_number.t - test bad step failure case in Parrot::Configure
+
+=head1 SYNOPSIS
+
+    % prove t/configure08-verbose_step_number.t
+
+=head1 DESCRIPTION
+
+The files in this directory test functionality used by F<Configure.pl>.
+
+The tests in this file examine what happens when you configure with the
+<--verbose-step> option set to C<1>.
+
+=head1 AUTHOR
+
+James E Keenan
+
+=head1 SEE ALSO
+
+Parrot::Configure, F<Configure.pl>.
+
+=cut
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/15-no_return.t
===================================================================
--- t/configure/15-no_return.t	(revision 0)
+++ t/configure/15-no_return.t	(revision 0)
@@ -0,0 +1,115 @@
+#! perl
+# Copyright (C) 2007, The Perl Foundation.
+# $Id: 15-no_return.t 18310 2007-04-24 01:27:22Z jkeenan $
+# 15-no_return.t
+
+use strict;
+use warnings;
+
+use Test::More tests => 15;
+use Carp;
+use lib qw( . lib ../lib ../../lib t/configure/testlib );
+use Parrot::BuildUtil;
+use Parrot::Configure;
+use Parrot::Configure::Options qw( process_options );
+use Parrot::IO::Capture::Mini;
+
+my $parrot_version = Parrot::BuildUtil::parrot_version();
+like($parrot_version, qr/\d+\.\d+\.\d+/,
+    "Parrot version is in 3-part format");
+
+$| = 1;
+is($|, 1, "output autoflush is set");
+
+my $args = process_options( {
+    argv            => [ ],
+    script          => $0,
+    parrot_version  => $parrot_version,
+    svnid           => '$Id: 15-no_return.t 18310 2007-04-24 01:27:22Z jkeenan $',
+} );
+ok(defined $args, "process_options returned successfully");
+my %args = %$args;
+
+my $conf = Parrot::Configure->new;
+ok(defined $conf, "Parrot::Configure->new() returned okay");
+
+my $step = q{init::epsilon};
+my $description = 'Determining if your computer does epsilon';
+
+$conf->add_steps( $step );
+my @confsteps = @{$conf->steps};
+isnt(scalar @confsteps, 0,
+    "Parrot::Configure object 'steps' key holds non-empty array reference");
+is(scalar @confsteps, 1,
+    "Parrot::Configure object 'steps' key holds ref to 1-element array");
+my $nontaskcount = 0;
+foreach my $k (@confsteps) {
+    $nontaskcount++ unless $k->isa("Parrot::Configure::Task");
+}
+is($nontaskcount, 0, "Each step is a Parrot::Configure::Task object");
+is($confsteps[0]->step, $step, 
+    "'step' element of Parrot::Configure::Task struct identified");
+is(ref($confsteps[0]->params), 'ARRAY',
+    "'params' element of Parrot::Configure::Task struct is array ref");
+ok(! ref($confsteps[0]->object),
+    "'object' element of Parrot::Configure::Task struct is not yet a ref");
+
+$conf->options->set(%args);
+is($conf->options->{c}->{debugging}, 1,
+    "command-line option '--debugging' has been stored in object");
+
+my $rv;
+my ($tie, @lines, $errstr);
+{
+    $tie = tie *STDOUT, "Parrot::IO::Capture::Mini"
+        or croak "Unable to tie";
+    local $SIG{__WARN__} = \&_capture;
+    $rv = $conf->runsteps;
+    @lines = $tie->READLINE;
+}
+ok($rv, "runsteps successfully ran $step");
+my $bigmsg = join q{}, @lines;
+like($bigmsg,
+    qr/$description/s,
+    "Got message expected upon running $step");
+like($errstr,
+    qr/step $step failed:\s*no result returned/s,
+    "Got error message expected when config module did not return object");
+
+pass("Completed all tests in $0");
+
+sub _capture { $errstr = $_[0];}
+
+################### DOCUMENTATION ###################
+
+=head1 NAME
+
+15-no_return.t - see what happens when configuration step does not return object
+
+=head1 SYNOPSIS
+
+    % prove t/configure15-no_return.t
+
+=head1 DESCRIPTION
+
+The files in this directory test functionality used by F<Configure.pl>.
+
+The tests in this file examine what happens when your configuration step
+module fails to return the object and does not have an explicit C<return>.
+
+=head1 AUTHOR
+
+James E Keenan
+
+=head1 SEE ALSO
+
+Parrot::Configure, F<Configure.pl>.
+
+=cut
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/11-no_description.t
===================================================================
--- t/configure/11-no_description.t	(revision 0)
+++ t/configure/11-no_description.t	(revision 0)
@@ -0,0 +1,109 @@
+#! perl
+# Copyright (C) 2007, The Perl Foundation.
+# $Id: 11-no_description.t 18310 2007-04-24 01:27:22Z jkeenan $
+# 11-no_description.t
+
+use strict;
+use warnings;
+
+use Test::More tests => 14;
+use Carp;
+use lib qw( . lib ../lib ../../lib t/configure/testlib );
+use Parrot::BuildUtil;
+use Parrot::Configure;
+use Parrot::Configure::Options qw( process_options );
+use Parrot::IO::Capture::Mini;
+
+my $parrot_version = Parrot::BuildUtil::parrot_version();
+like($parrot_version, qr/\d+\.\d+\.\d+/,
+    "Parrot version is in 3-part format");
+
+$| = 1;
+is($|, 1, "output autoflush is set");
+
+my $args = process_options( {
+    argv            => [ ],
+    script          => $0,
+    parrot_version  => $parrot_version,
+    svnid           => '$Id: 11-no_description.t 18310 2007-04-24 01:27:22Z jkeenan $',
+} );
+ok(defined $args, "process_options returned successfully");
+my %args = %$args;
+
+my $conf = Parrot::Configure->new;
+ok(defined $conf, "Parrot::Configure->new() returned okay");
+
+my $step = q{init::alpha};
+my $description = q{};
+
+$conf->add_steps( $step );
+my @confsteps = @{$conf->steps};
+isnt(scalar @confsteps, 0,
+    "Parrot::Configure object 'steps' key holds non-empty array reference");
+is(scalar @confsteps, 1,
+    "Parrot::Configure object 'steps' key holds ref to 1-element array");
+my $nontaskcount = 0;
+foreach my $k (@confsteps) {
+    $nontaskcount++ unless $k->isa("Parrot::Configure::Task");
+}
+is($nontaskcount, 0, "Each step is a Parrot::Configure::Task object");
+is($confsteps[0]->step, $step, 
+    "'step' element of Parrot::Configure::Task struct identified");
+is(ref($confsteps[0]->params), 'ARRAY',
+    "'params' element of Parrot::Configure::Task struct is array ref");
+ok(! ref($confsteps[0]->object),
+    "'object' element of Parrot::Configure::Task struct is not yet a ref");
+
+$conf->options->set(%args);
+is($conf->options->{c}->{debugging}, 1,
+    "command-line option '--debugging' has been stored in object");
+
+my $rv;
+my ($tie, @lines);
+{
+    $tie = tie *STDOUT, "Parrot::IO::Capture::Mini"
+        or croak "Unable to tie";
+    $rv = $conf->runsteps;
+    @lines = $tie->READLINE;
+}
+ok($rv, "runsteps successfully ran $step");
+my $bigmsg = join q{}, @lines;
+like($bigmsg,
+    qr/$description\.\.\..*done./s,
+    "Got message expected upon running $step");
+
+pass("Completed all tests in $0");
+
+################### DOCUMENTATION ###################
+
+=head1 NAME
+
+11-no_description.t - test what happens when a configuration step has no C<$description> defined
+
+=head1 SYNOPSIS
+
+    % prove t/configure11-no_description.t
+
+=head1 DESCRIPTION
+
+The files in this directory test functionality used by F<Configure.pl>.
+
+The tests in this file examine what happens when your configuration step fails
+to define C<$description>.
+
+=head1 AUTHOR
+
+James E Keenan
+
+=head1 SEE ALSO
+
+Parrot::Configure, F<Configure.pl>.
+
+=cut
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/04-configure.t
===================================================================
--- t/configure/04-configure.t	(revision 0)
+++ t/configure/04-configure.t	(revision 0)
@@ -0,0 +1,140 @@
+#! perl
+# Copyright (C) 2007, The Perl Foundation.
+# $Id: 04-configure.t 18310 2007-04-24 01:27:22Z jkeenan $
+# 04-configure.t
+
+use strict;
+use warnings;
+
+use Test::More tests => 30;
+use Carp;
+use lib qw( . lib ../lib ../../lib );
+use Parrot::BuildUtil;
+use Parrot::Configure;
+use Parrot::Configure::Options qw( process_options );
+use_ok('Parrot::Configure::Step::List', qw|
+    get_steps_list
+| );
+
+my $parrot_version = Parrot::BuildUtil::parrot_version();
+like($parrot_version, qr/\d+\.\d+\.\d+/,
+    "Parrot version is in 3-part format");
+
+$| = 1;
+is($|, 1, "output autoflush is set");
+
+my $CC = "/usr/bin/gcc-3.3";
+my $localargv = [
+    qq{--cc=$CC},
+    qq{--step=init::manifest},
+];
+my $args = process_options( {
+    argv            => $localargv,
+    script          => $0,
+    parrot_version  => $parrot_version,
+    svnid           => '$Id: 04-configure.t 18310 2007-04-24 01:27:22Z jkeenan $',
+} );
+ok(defined $args, "process_options returned successfully");
+my %args = %$args;
+
+my $conf = Parrot::Configure->new;
+ok(defined $conf, "Parrot::Configure->new() returned okay");
+isa_ok($conf, "Parrot::Configure");
+
+my $newconf = Parrot::Configure->new;
+ok(defined $newconf, "Parrot::Configure->new() returned okay");
+isa_ok($newconf, "Parrot::Configure");
+is($conf, $newconf, "Parrot::Configure object is a singleton");
+
+# Since these tests peek into the Parrot::Configure object, they will break if
+# the structure of that object changes.  We retain them for now to delineate
+# our progress in testing the object.
+foreach my $k (qw| steps options data |) {
+    ok(defined $conf->$k, "Parrot::Configure object has $k key");
+}
+is(ref($conf->steps), q{ARRAY},
+    "Parrot::Configure object 'steps' key is array reference");
+is(scalar @{$conf->steps}, 0,
+    "Parrot::Configure object 'steps' key holds empty array reference");
+foreach my $k (qw| options data |) {
+    isa_ok($conf->$k, "Parrot::Configure::Data");
+}
+
+can_ok("Parrot::Configure", qw| data |);
+can_ok("Parrot::Configure", qw| options |);
+can_ok("Parrot::Configure", qw| steps |);
+can_ok("Parrot::Configure", qw| add_step |);
+can_ok("Parrot::Configure", qw| add_steps |);
+can_ok("Parrot::Configure", qw| runstep |);
+can_ok("Parrot::Configure", qw| runsteps |);
+can_ok("Parrot::Configure", qw| _runstep |);
+
+$conf->add_steps(get_steps_list());
+my @confsteps = @{$conf->steps};
+isnt(scalar @confsteps, 0,
+    "Parrot::Configure object 'steps' key holds non-empty array reference");
+my $nontaskcount = 0;
+foreach my $k (@confsteps) {
+    $nontaskcount++ unless $k->isa("Parrot::Configure::Task");
+}
+is($nontaskcount, 0, "Each step is a Parrot::Configure::Task object");
+
+$conf->options->set(%args);
+is($conf->options->{c}->{cc}, $CC,
+    "command-line option '--cc' has been stored in object");
+is($conf->options->{c}->{debugging}, 1,
+    "command-line option '--debugging' has been stored in object");
+
+my $res  = eval "no strict; use Parrot::Config::Generated; \\%PConfig";
+SKIP: {
+    my $reason = <<REASON;
+If you have already completed configuration, 
+you can call Parrot::Configure::Data::slurp().
+But here you are testing for that method's failure.
+REASON
+
+    skip $reason, 1 if defined $res;
+
+    eval { $conf->data()->slurp(); };
+    like($@,
+        qr/You cannot use --step until you have completed the full configure process/,
+        "Got expected error message when using --step option without prior completed configuration");
+}
+
+pass("Completed all tests in $0");
+
+################### DOCUMENTATION ###################
+
+=head1 NAME
+
+04-configure.t - test Parrot::Configure
+
+=head1 SYNOPSIS
+
+    % prove t/configure04-configure.t
+
+=head1 DESCRIPTION
+
+The files in this directory test functionality used by F<Configure.pl>.
+
+The tests in this file test those Parrot::Configure methods regularly called
+by F<Configure.pl> up to, but not including, C<Parrot::Configure::runsteps()>.
+There is also a test for failure of the C<--step> option without prior
+completed configuration.
+
+=head1 AUTHOR
+
+James E Keenan
+
+=head1 SEE ALSO
+
+Parrot::Configure, F<Configure.pl>.
+
+=cut
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/testlib/init/alpha.pm
===================================================================
--- t/configure/testlib/init/alpha.pm	(revision 0)
+++ t/configure/testlib/init/alpha.pm	(revision 0)
@@ -0,0 +1,35 @@
+# Copyright (C) 2001-2003, The Perl Foundation.
+# $Id: alpha.pm 18226 2007-04-15 17:23:44Z jkeenan $
+
+=head1 NAME
+
+t/configure/testlib/init/alpha.pm - Module used in configuration tests
+
+=cut
+
+package init::alpha;
+use strict;
+use warnings;
+use vars qw($description @args);
+
+use base qw(Parrot::Configure::Step::Base);
+
+use Parrot::Configure::Step;
+
+$description = undef;
+@args = ();
+
+sub runstep {
+    my ( $self, $conf ) = @_;
+    print "\nYou've got alpha\n";
+    return $self;
+}
+
+1;
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/testlib/init/foobar.pm
===================================================================
--- t/configure/testlib/init/foobar.pm	(revision 0)
+++ t/configure/testlib/init/foobar.pm	(revision 0)
@@ -0,0 +1,35 @@
+# Copyright (C) 2001-2003, The Perl Foundation.
+# $Id: foobar.pm 18222 2007-04-15 15:57:33Z jkeenan $
+
+=head1 NAME
+
+t/configure/testlib/init/foobar.pm - Module used in configuration tests
+
+=cut
+
+package init::foobar;
+use strict;
+use warnings;
+use vars qw($description @args);
+
+use base qw(Parrot::Configure::Step::Base);
+
+use Parrot::Configure::Step;
+
+$description = 'Determining if your computer does foobar';
+@args = ();
+
+sub runstep {
+    my ( $self, $conf ) = @_;
+    print "\nYou've got foobar\n";
+    return $self;
+}
+
+1;
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/testlib/init/delta.pm
===================================================================
--- t/configure/testlib/init/delta.pm	(revision 0)
+++ t/configure/testlib/init/delta.pm	(revision 0)
@@ -0,0 +1,35 @@
+# Copyright (C) 2001-2003, The Perl Foundation.
+# $Id: delta.pm 18282 2007-04-19 02:06:50Z jkeenan $
+
+=head1 NAME
+
+t/configure/testlib/init/delta.pm - Module used in configuration tests
+
+=cut
+
+package init::delta;
+use strict;
+use warnings;
+use vars qw($description @args);
+
+use base qw(Parrot::Configure::Step::Base);
+
+use Parrot::Configure::Step;
+
+$description = 'Determining if your computer does delta';
+@args = ();
+
+sub runstep {
+    my ( $self, $conf, @params ) = @_;
+    print "\n@params\n";
+    return $self;
+}
+
+1;
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/testlib/init/epsilon.pm
===================================================================
--- t/configure/testlib/init/epsilon.pm	(revision 0)
+++ t/configure/testlib/init/epsilon.pm	(revision 0)
@@ -0,0 +1,33 @@
+# Copyright (C) 2001-2003, The Perl Foundation.
+# $Id: epsilon.pm 18281 2007-04-19 02:05:11Z jkeenan $
+
+=head1 NAME
+
+t/configure/testlib/init/epsilon.pm - Module used in configuration tests
+
+=cut
+
+package init::epsilon;
+use strict;
+use warnings;
+use vars qw($description @args);
+
+use base qw(Parrot::Configure::Step::Base);
+
+use Parrot::Configure::Step;
+
+$description = 'Determining if your computer does epsilon';
+@args = ();
+
+sub runstep {
+    my ( $self, $conf ) = @_;
+}
+
+1;
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/testlib/init/beta.pm
===================================================================
--- t/configure/testlib/init/beta.pm	(revision 0)
+++ t/configure/testlib/init/beta.pm	(revision 0)
@@ -0,0 +1,37 @@
+# Copyright (C) 2001-2003, The Perl Foundation.
+# $Id: beta.pm 18226 2007-04-15 17:23:44Z jkeenan $
+
+=head1 NAME
+
+t/configure/testlib/init/beta.pm - Module used in configuration tests
+
+=cut
+
+package init::beta;
+use strict;
+use warnings;
+use vars qw($description @args);
+
+use base qw(Parrot::Configure::Step::Base);
+
+use Parrot::Configure::Step;
+
+$description = 'Determining if your computer does beta';
+@args = qw( verbose );
+
+sub runstep {
+    my ( $self, $conf ) = @_;
+    my $verbose = $conf->options->get('verbose');
+    print "\nbeta is verbose\n" if $verbose;
+    print "\nYou've got beta\n";
+    return $self;
+}
+
+1;
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/testlib/init/gamma.pm
===================================================================
--- t/configure/testlib/init/gamma.pm	(revision 0)
+++ t/configure/testlib/init/gamma.pm	(revision 0)
@@ -0,0 +1,34 @@
+# Copyright (C) 2001-2003, The Perl Foundation.
+# $Id: gamma.pm 18232 2007-04-16 02:31:53Z jkeenan $
+
+=head1 NAME
+
+t/configure/testlib/init/gamma.pm - Module used in configuration tests
+
+=cut
+
+package init::gamma;
+use strict;
+use warnings;
+use vars qw($description @args);
+
+use base qw(Parrot::Configure::Step::Base);
+
+use Parrot::Configure::Step;
+
+$description = 'Determining if your computer does gamma';
+@args = ();
+
+sub runstep {
+    my ( $self, $conf ) = @_;
+    die "Dying gamma just to see what happens";
+}
+
+1;
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/testlib/init/zeta.pm
===================================================================
--- t/configure/testlib/init/zeta.pm	(revision 0)
+++ t/configure/testlib/init/zeta.pm	(revision 0)
@@ -0,0 +1,39 @@
+# Copyright (C) 2001-2003, The Perl Foundation.
+# $Id: zeta.pm 18281 2007-04-19 02:05:11Z jkeenan $
+
+=head1 NAME
+
+t/configure/testlib/init/zeta.pm - Module used in configuration tests
+
+=cut
+
+package init::zeta;
+use strict;
+use warnings;
+use vars qw($description @args);
+# use vars qw($description @args $step);
+
+use base qw(Parrot::Configure::Step::Base);
+
+use Parrot::Configure::Step;
+
+$description = 'Determining if your computer does zeta';
+@args = ();
+
+my $result = q|Hello world|;
+sub runstep {
+    my ( $self, $conf ) = @_;
+    $self->set_result( $result );
+    return $self;
+#    $self->result();
+}
+
+
+1;
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/06-bad_step.t
===================================================================
--- t/configure/06-bad_step.t	(revision 0)
+++ t/configure/06-bad_step.t	(revision 0)
@@ -0,0 +1,100 @@
+#! perl
+# Copyright (C) 2007, The Perl Foundation.
+# $Id: 06-bad_step.t 18310 2007-04-24 01:27:22Z jkeenan $
+# 06-bad_step.t
+
+use strict;
+use warnings;
+
+use Test::More tests => 13;
+use Carp;
+use lib qw( . lib ../lib ../../lib );
+use Parrot::BuildUtil;
+use Parrot::Configure;
+use Parrot::Configure::Options qw( process_options );
+use Parrot::IO::Capture::Mini;
+
+my $parrot_version = Parrot::BuildUtil::parrot_version();
+like($parrot_version, qr/\d+\.\d+\.\d+/,
+    "Parrot version is in 3-part format");
+
+$| = 1;
+is($|, 1, "output autoflush is set");
+
+my $args = process_options( {
+    argv            => [],
+    script          => $0,
+    parrot_version  => $parrot_version,
+    svnid           => '$Id: 06-bad_step.t 18310 2007-04-24 01:27:22Z jkeenan $',
+} );
+ok(defined $args, "process_options returned successfully");
+my %args = %$args;
+
+my $conf = Parrot::Configure->new;
+ok(defined $conf, "Parrot::Configure->new() returned okay");
+
+my $badstep = q{bad::step};
+my $badsteppath = q{bad/step.pm};
+
+$conf->add_steps( $badstep );
+my @confsteps = @{$conf->steps};
+isnt(scalar @confsteps, 0,
+    "Parrot::Configure object 'steps' key holds non-empty array reference");
+is(scalar @confsteps, 1,
+    "Parrot::Configure object 'steps' key holds ref to 1-element array");
+my $nontaskcount = 0;
+foreach my $k (@confsteps) {
+    $nontaskcount++ unless $k->isa("Parrot::Configure::Task");
+}
+is($nontaskcount, 0, "Each step is a Parrot::Configure::Task object");
+is($confsteps[0]->step, $badstep, 
+    "'step' element of Parrot::Configure::Task struct identified");
+is(ref($confsteps[0]->params), 'ARRAY',
+    "'params' element of Parrot::Configure::Task struct is array ref");
+ok(! ref($confsteps[0]->object),
+    "'object' element of Parrot::Configure::Task struct is not yet a ref");
+
+$conf->options->set(%args);
+is($conf->options->{c}->{debugging}, 1,
+    "command-line option '--debugging' has been stored in object");
+
+my $rv;
+eval { $rv = $conf->runsteps; };
+like($@, qr/Can't locate $badsteppath in \@INC/,  #'
+    "Got expected die message when runsteps() called with nonexistent step");
+
+pass("Completed all tests in $0");
+
+################### DOCUMENTATION ###################
+
+=head1 NAME
+
+06-bad_step.t - test bad step failure case in Parrot::Configure
+
+=head1 SYNOPSIS
+
+    % prove t/configure06-bad_step.t
+
+=head1 DESCRIPTION
+
+The files in this directory test functionality used by F<Configure.pl>.
+
+The tests in this file examine what happens when you attempt to do a
+C<runsteps> on a non-existent step.
+
+=head1 AUTHOR
+
+James E Keenan
+
+=head1 SEE ALSO
+
+Parrot::Configure, F<Configure.pl>.
+
+=cut
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/14-params.t
===================================================================
--- t/configure/14-params.t	(revision 0)
+++ t/configure/14-params.t	(revision 0)
@@ -0,0 +1,113 @@
+#! perl
+# Copyright (C) 2007, The Perl Foundation.
+# $Id: 14-params.t 18310 2007-04-24 01:27:22Z jkeenan $
+# 14-params.t
+
+use strict;
+use warnings;
+
+use Test::More tests => 14;
+use Carp;
+use lib qw( . lib ../lib ../../lib t/configure/testlib );
+use Parrot::BuildUtil;
+use Parrot::Configure;
+use Parrot::Configure::Options qw( process_options );
+use Parrot::IO::Capture::Mini;
+
+my $parrot_version = Parrot::BuildUtil::parrot_version();
+like($parrot_version, qr/\d+\.\d+\.\d+/,
+    "Parrot version is in 3-part format");
+
+$| = 1;
+is($|, 1, "output autoflush is set");
+
+my $args = process_options( {
+    argv            => [ ],
+    script          => $0,
+    parrot_version  => $parrot_version,
+    svnid           => '$Id: 14-params.t 18310 2007-04-24 01:27:22Z jkeenan $',
+} );
+ok(defined $args, "process_options returned successfully");
+my %args = %$args;
+
+my $conf = Parrot::Configure->new;
+ok(defined $conf, "Parrot::Configure->new() returned okay");
+
+my $step = q{init::delta};
+my $description = 'Determining if your computer does delta';
+my @params = qw| delta phi beta kappa |;
+my $paramstr = join q{ }, @params;
+
+$conf->add_step( $step, @params );
+my @confsteps = @{$conf->steps};
+
+isnt(scalar @confsteps, 0,
+    "Parrot::Configure object 'steps' key holds non-empty array reference");
+is(scalar @confsteps, 1,
+    "Parrot::Configure object 'steps' key holds ref to 1-element array");
+my $nontaskcount = 0;
+foreach my $k (@confsteps) {
+    $nontaskcount++ unless $k->isa("Parrot::Configure::Task");
+}
+is($nontaskcount, 0, "Each step is a Parrot::Configure::Task object");
+is($confsteps[0]->step, $step, 
+    "'step' element of Parrot::Configure::Task struct identified");
+is(ref($confsteps[0]->params), 'ARRAY',
+    "'params' element of Parrot::Configure::Task struct is array ref");
+ok(! ref($confsteps[0]->object),
+    "'object' element of Parrot::Configure::Task struct is not yet a ref");
+
+$conf->options->set(%args);
+is($conf->options->{c}->{debugging}, 1,
+    "command-line option '--debugging' has been stored in object");
+
+my $rv;
+my ($tie, @lines);
+{
+    $tie = tie *STDOUT, "Parrot::IO::Capture::Mini"
+        or croak "Unable to tie";
+    $rv = $conf->runsteps;
+    @lines = $tie->READLINE;
+}
+ok($rv, "runsteps successfully ran $step");
+my $bigmsg = join q{}, @lines;
+like($bigmsg,
+    qr/$description\.\.\..*$paramstr.*done\./s,
+    "Got message expected upon running $step");
+
+pass("Completed all tests in $0");
+
+################### DOCUMENTATION ###################
+
+=head1 NAME
+
+14-params.t - test what happens when a step is registered with parameters
+
+=head1 SYNOPSIS
+
+    % prove t/configure14-params.t
+
+=head1 DESCRIPTION
+
+The files in this directory test functionality used by F<Configure.pl>.
+
+The tests in this file examine what happens when you register a configuration
+step with parameter.  (This feature does not appear to be in current (April
+16, 2007) use.)
+
+=head1 AUTHOR
+
+James E Keenan
+
+=head1 SEE ALSO
+
+Parrot::Configure, F<Configure.pl>.
+
+=cut
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/16-no_return_but_result.t
===================================================================
--- t/configure/16-no_return_but_result.t	(revision 0)
+++ t/configure/16-no_return_but_result.t	(revision 0)
@@ -0,0 +1,117 @@
+#! perl
+# Copyright (C) 2007, The Perl Foundation.
+# $Id: 16-no_return_but_result.t 18310 2007-04-24 01:27:22Z jkeenan $
+# 16-no_return_but_result.t
+
+use strict;
+use warnings;
+
+use Test::More qw(no_plan); # tests => 15;
+use Carp;
+use lib qw( . lib ../lib ../../lib t/configure/testlib );
+use Parrot::BuildUtil;
+use Parrot::Configure;
+use Parrot::Configure::Options qw( process_options );
+use Parrot::IO::Capture::Mini;
+
+my $parrot_version = Parrot::BuildUtil::parrot_version();
+like($parrot_version, qr/\d+\.\d+\.\d+/,
+    "Parrot version is in 3-part format");
+
+$| = 1;
+is($|, 1, "output autoflush is set");
+
+my $args = process_options( {
+    argv            => [ ],
+    script          => $0,
+    parrot_version  => $parrot_version,
+    svnid           => '$Id: 16-no_return_but_result.t 18310 2007-04-24 01:27:22Z jkeenan $',
+} );
+ok(defined $args, "process_options returned successfully");
+my %args = %$args;
+
+my $conf = Parrot::Configure->new;
+ok(defined $conf, "Parrot::Configure->new() returned okay");
+
+my $step = q{init::epsilon};
+my $description = 'Determining if your computer does epsilon';
+
+$conf->add_steps( $step );
+my @confsteps = @{$conf->steps};
+isnt(scalar @confsteps, 0,
+    "Parrot::Configure object 'steps' key holds non-empty array reference");
+is(scalar @confsteps, 1,
+    "Parrot::Configure object 'steps' key holds ref to 1-element array");
+my $nontaskcount = 0;
+foreach my $k (@confsteps) {
+    $nontaskcount++ unless $k->isa("Parrot::Configure::Task");
+}
+is($nontaskcount, 0, "Each step is a Parrot::Configure::Task object");
+is($confsteps[0]->step, $step, 
+    "'step' element of Parrot::Configure::Task struct identified");
+is(ref($confsteps[0]->params), 'ARRAY',
+    "'params' element of Parrot::Configure::Task struct is array ref");
+ok(! ref($confsteps[0]->object),
+    "'object' element of Parrot::Configure::Task struct is not yet a ref");
+
+$conf->options->set(%args);
+is($conf->options->{c}->{debugging}, 1,
+    "command-line option '--debugging' has been stored in object");
+
+my $rv;
+my ($tie, @lines, $errstr);
+#{
+#    $tie = tie *STDOUT, "Parrot::IO::Capture::Mini"
+#        or croak "Unable to tie";
+##    local $SIG{__WARN__} = \&_capture;
+#    $rv = $conf->runsteps;
+#    @lines = $tie->READLINE;
+#}
+#ok($rv, "runsteps successfully ran $step");
+#my $bigmsg = join q{}, @lines;
+#like($bigmsg,
+#    qr/$description/s,
+#    "Got message expected upon running $step");
+#like($errstr,
+#    qr/step $step failed:\s*Hello world/s,
+#    "Got error message expected when config module did not return object");
+
+pass("Completed all tests in $0");
+
+sub _capture { $errstr = $_[0];}
+
+################### DOCUMENTATION ###################
+
+=head1 NAME
+
+16-no_return_but_result.t - see what happens when configuration step returns
+something other than object but has a defined result method
+
+=head1 SYNOPSIS
+
+    % prove t/configure16-no_return_but_result.t
+
+=head1 DESCRIPTION
+
+The files in this directory test functionality used by F<Configure.pl>.
+
+The tests in this file examine what happens when your configuration step
+module returns something other than the object but has some other defined
+result method.
+
+=head1 AUTHOR
+
+James E Keenan
+
+=head1 SEE ALSO
+
+Parrot::Configure, F<Configure.pl>.
+
+=cut
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/configure/10-verbose_step_number_not_called.t
===================================================================
--- t/configure/10-verbose_step_number_not_called.t	(revision 0)
+++ t/configure/10-verbose_step_number_not_called.t	(revision 0)
@@ -0,0 +1,110 @@
+#! perl
+# Copyright (C) 2007, The Perl Foundation.
+# $Id: 10-verbose_step_number_not_called.t 18310 2007-04-24 01:27:22Z jkeenan $
+# 10-verbose_step_number_not_called.t
+
+use strict;
+use warnings;
+
+use Test::More tests => 14;
+use Carp;
+use lib qw( . lib ../lib ../../lib t/configure/testlib );
+use Parrot::BuildUtil;
+use Parrot::Configure;
+use Parrot::Configure::Options qw( process_options );
+use Parrot::IO::Capture::Mini;
+
+my $parrot_version = Parrot::BuildUtil::parrot_version();
+like($parrot_version, qr/\d+\.\d+\.\d+/,
+    "Parrot version is in 3-part format");
+
+$| = 1;
+is($|, 1, "output autoflush is set");
+
+my $args = process_options( {
+    argv            => [ q{--verbose-step=2} ],
+    script          => $0,
+    parrot_version  => $parrot_version,
+    svnid           => '$Id: 10-verbose_step_number_not_called.t 18310 2007-04-24 01:27:22Z jkeenan $',
+} );
+ok(defined $args, "process_options returned successfully");
+my %args = %$args;
+
+my $conf = Parrot::Configure->new;
+ok(defined $conf, "Parrot::Configure->new() returned okay");
+
+my $step = q{init::foobar};
+my $description = 'Determining if your computer does foobar';
+
+$conf->add_steps( $step );
+my @confsteps = @{$conf->steps};
+isnt(scalar @confsteps, 0,
+    "Parrot::Configure object 'steps' key holds non-empty array reference");
+is(scalar @confsteps, 1,
+    "Parrot::Configure object 'steps' key holds ref to 1-element array");
+my $nontaskcount = 0;
+foreach my $k (@confsteps) {
+    $nontaskcount++ unless $k->isa("Parrot::Configure::Task");
+}
+is($nontaskcount, 0, "Each step is a Parrot::Configure::Task object");
+is($confsteps[0]->step, $step, 
+    "'step' element of Parrot::Configure::Task struct identified");
+is(ref($confsteps[0]->params), 'ARRAY',
+    "'params' element of Parrot::Configure::Task struct is array ref");
+ok(! ref($confsteps[0]->object),
+    "'object' element of Parrot::Configure::Task struct is not yet a ref");
+
+$conf->options->set(%args);
+is($conf->options->{c}->{debugging}, 1,
+    "command-line option '--debugging' has been stored in object");
+
+my $rv;
+my ($tie, @lines);
+{
+    $tie = tie *STDOUT, "Parrot::IO::Capture::Mini"
+        or croak "Unable to tie";
+    $rv = $conf->runsteps;
+    @lines = $tie->READLINE;
+}
+ok($rv, "runsteps successfully ran $step");
+my $bigmsg = join q{}, @lines;
+like($bigmsg,
+    qr/$description\.\.\..*done\.(?!\s+Setting Configuration Data)/s,
+    "Got message expected upon running $step");
+
+pass("Completed all tests in $0");
+
+################### DOCUMENTATION ###################
+
+=head1 NAME
+
+10-verbose_step_number_not_called.t - test bad step failure case in Parrot::Configure
+
+=head1 SYNOPSIS
+
+    % prove t/configure10-verbose_step_number_not_called.t
+
+=head1 DESCRIPTION
+
+The files in this directory test functionality used by F<Configure.pl>.
+
+The tests in this file examine what happens when you configure with the
+<--verbose-step> option set to a number that does not correspond to the
+sequence position of the associated step.
+
+=head1 AUTHOR
+
+James E Keenan
+
+=head1 SEE ALSO
+
+Parrot::Configure, F<Configure.pl>.
+
+=cut
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:
Index: t/postconfigure/01-data_slurp.t
===================================================================
--- t/postconfigure/01-data_slurp.t	(revision 0)
+++ t/postconfigure/01-data_slurp.t	(revision 0)
@@ -0,0 +1,154 @@
+#! perl
+# Copyright (C) 2007, The Perl Foundation.
+# $Id: 01-data_slurp.t 18283 2007-04-19 03:01:07Z jkeenan $
+# 01-data_slurp.t
+
+use strict;
+use warnings;
+
+BEGIN {
+    use FindBin qw($Bin);
+    use Cwd qw(cwd realpath);
+    realpath($Bin) =~ m{^(.*\/parrot)\/[^/]*\/[^/]*\/[^/]*$};
+    our $topdir = $1;
+    if ( defined $topdir ) {
+        print "\nOK:  Parrot top directory located\n";
+    }
+    else {
+        $topdir = realpath($Bin) . "/../..";
+    }
+    unshift @INC, qq{$topdir/lib};
+}
+use Test::More tests => 30;
+use Carp;
+use Data::Dumper;
+$Data::Dumper::Indent=1;
+use Parrot::BuildUtil;
+use Parrot::Configure;
+use Parrot::Configure::Options qw( process_options );
+use_ok('Parrot::Configure::Step::List', qw|
+    get_steps_list
+| );
+
+my $parrot_version = Parrot::BuildUtil::parrot_version();
+like($parrot_version, qr/\d+\.\d+\.\d+/,
+    "Parrot version is in 3-part format");
+
+$| = 1;
+is($|, 1, "output autoflush is set");
+
+my $CC = "/usr/bin/gcc-3.3";
+my $localargv = [
+    qq{--cc=$CC},
+    qq{--step=init::manifest},
+];
+my $args = process_options( {
+    argv            => $localargv,
+    script          => $0,
+    parrot_version  => $parrot_version,
+    svnid           => '$Id: 01-data_slurp.t 18283 2007-04-19 03:01:07Z jkeenan $',
+} );
+ok(defined $args, "process_options returned successfully");
+my %args = %$args;
+
+my $conf = Parrot::Configure->new;
+ok(defined $conf, "Parrot::Configure->new() returned okay");
+isa_ok($conf, "Parrot::Configure");
+
+my $newconf = Parrot::Configure->new;
+ok(defined $newconf, "Parrot::Configure->new() returned okay");
+isa_ok($newconf, "Parrot::Configure");
+is($conf, $newconf, "Parrot::Configure object is a singleton");
+
+# Since these tests peek into the Parrot::Configure object, they will break if
+# the structure of that object changes.  We retain them for now to delineate
+# our progress in testing the object.
+foreach my $k (qw| steps options data |) {
+    ok(defined $conf->$k, "Parrot::Configure object has $k key");
+}
+is(ref($conf->steps), q{ARRAY},
+    "Parrot::Configure object 'steps' key is array reference");
+is(scalar @{$conf->steps}, 0,
+    "Parrot::Configure object 'steps' key holds empty array reference");
+foreach my $k (qw| options data |) {
+    isa_ok($conf->$k, "Parrot::Configure::Data");
+}
+
+can_ok("Parrot::Configure", qw| data |);
+can_ok("Parrot::Configure", qw| options |);
+can_ok("Parrot::Configure", qw| steps |);
+can_ok("Parrot::Configure", qw| add_step |);
+can_ok("Parrot::Configure", qw| add_steps |);
+can_ok("Parrot::Configure", qw| runstep |);
+can_ok("Parrot::Configure", qw| runsteps |);
+can_ok("Parrot::Configure", qw| _runstep |);
+
+$conf->add_steps(get_steps_list());
+my @confsteps = @{$conf->steps};
+isnt(scalar @confsteps, 0,
+    "Parrot::Configure object 'steps' key holds non-empty array reference");
+my $nontaskcount = 0;
+foreach my $k (@confsteps) {
+    $nontaskcount++ unless $k->isa("Parrot::Configure::Task");
+}
+is($nontaskcount, 0, "Each step is a Parrot::Configure::Task object");
+
+$conf->options->set(%args);
+is($conf->options->{c}->{cc}, $CC,
+    "command-line option '--cc' has been stored in object");
+is($conf->options->{c}->{debugging}, 1,
+    "command-line option '--debugging' has been stored in object");
+
+my $res  = eval "no strict; use Parrot::Config; \\%PConfig";
+SKIP: {
+    my $reason = <<REASON;
+If you have already completed configuration, 
+you can call Parrot::Configure::Data::slurp().
+But here you are testing for that method's failure.
+REASON
+
+    skip $reason, 1 unless defined $res;
+
+    eval { $conf->data()->slurp(); };
+    ok( (defined $@) && (! $@), "Parrot::Configure::slurp() succeeded");
+}
+
+pass("Completed all tests in $0");
+
+################### DOCUMENTATION ###################
+
+=head1 NAME
+
+01-data_slurp.t - test Parrot::Configure::Data::slurp() once configuration has been completed
+
+=head1 SYNOPSIS
+
+    % prove t/postconfigure/01-data_slurp.t
+
+=head1 DESCRIPTION
+
+The files in this directory test functionality used by F<Configure.pl>.
+Certain of the modules C<use>d by F<Configure.pl> have functionality which is
+only meaningful I<after> F<Configure.pl> has actually been run and
+Parrot::Config::Generated has been created.  So certain tests need to be run
+when your Parrot filesystem is in a "pre-F<make>, post-F<Configure.pl> state.
+
+The tests in this file test C<Parrot::Configure::Data::slurp()>.  What is
+'slurped' here is an already created C<%Parrot::Config::PConfig>.
+
+=head1 AUTHOR
+
+James E Keenan
+
+=head1 SEE ALSO
+
+Parrot::Configure, F<Configure.pl>.
+
+=cut
+
+# Local Variables:
+#   mode: cperl
+#   cperl-indent-level: 4
+#   fill-column: 100
+# End:
+# vim: expandtab shiftwidth=4:

------------=_1177710237-30201-219--

